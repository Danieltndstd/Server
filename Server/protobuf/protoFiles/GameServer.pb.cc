// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameServer.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "GameServer.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace GameServer {

void protobuf_ShutdownFile_GameServer_2eproto() {
  delete tagUserStatus::default_instance_;
  delete tagUserScore::default_instance_;
  delete GSLogonTokenID::default_instance_;
  delete GSLogonSuccess::default_instance_;
  delete GSLogonFinish::default_instance_;
  delete GSLogonFailure::default_instance_;
  delete GSUserSitDown::default_instance_;
  delete GSUserStandUp::default_instance_;
  delete GSUserChangeTable::default_instance_;
  delete GSUserRequestFailure::default_instance_;
  delete GSUserEnter::default_instance_;
  delete GSUserLeave::default_instance_;
  delete GSUserStatus::default_instance_;
  delete GSUserScore::default_instance_;
  delete GSGameOption::default_instance_;
  delete GSUserReady::default_instance_;
  delete Proto_GameStatus::default_instance_;
  delete SQL_S_Scroll_Message::default_instance_;
  delete GSSystemMessage::default_instance_;
  delete GSUserHeart::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_GameServer_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_GameServer_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  tagUserStatus::default_instance_ = new tagUserStatus();
  tagUserScore::default_instance_ = new tagUserScore();
  GSLogonTokenID::default_instance_ = new GSLogonTokenID();
  GSLogonSuccess::default_instance_ = new GSLogonSuccess();
  GSLogonFinish::default_instance_ = new GSLogonFinish();
  GSLogonFailure::default_instance_ = new GSLogonFailure();
  GSUserSitDown::default_instance_ = new GSUserSitDown();
  GSUserStandUp::default_instance_ = new GSUserStandUp();
  GSUserChangeTable::default_instance_ = new GSUserChangeTable();
  GSUserRequestFailure::default_instance_ = new GSUserRequestFailure();
  GSUserEnter::default_instance_ = new GSUserEnter();
  GSUserLeave::default_instance_ = new GSUserLeave();
  GSUserStatus::default_instance_ = new GSUserStatus();
  GSUserScore::default_instance_ = new GSUserScore();
  GSGameOption::default_instance_ = new GSGameOption();
  GSUserReady::default_instance_ = new GSUserReady();
  Proto_GameStatus::default_instance_ = new Proto_GameStatus();
  SQL_S_Scroll_Message::default_instance_ = new SQL_S_Scroll_Message();
  GSSystemMessage::default_instance_ = new GSSystemMessage();
  GSUserHeart::default_instance_ = new GSUserHeart();
  tagUserStatus::default_instance_->InitAsDefaultInstance();
  tagUserScore::default_instance_->InitAsDefaultInstance();
  GSLogonTokenID::default_instance_->InitAsDefaultInstance();
  GSLogonSuccess::default_instance_->InitAsDefaultInstance();
  GSLogonFinish::default_instance_->InitAsDefaultInstance();
  GSLogonFailure::default_instance_->InitAsDefaultInstance();
  GSUserSitDown::default_instance_->InitAsDefaultInstance();
  GSUserStandUp::default_instance_->InitAsDefaultInstance();
  GSUserChangeTable::default_instance_->InitAsDefaultInstance();
  GSUserRequestFailure::default_instance_->InitAsDefaultInstance();
  GSUserEnter::default_instance_->InitAsDefaultInstance();
  GSUserLeave::default_instance_->InitAsDefaultInstance();
  GSUserStatus::default_instance_->InitAsDefaultInstance();
  GSUserScore::default_instance_->InitAsDefaultInstance();
  GSGameOption::default_instance_->InitAsDefaultInstance();
  GSUserReady::default_instance_->InitAsDefaultInstance();
  Proto_GameStatus::default_instance_->InitAsDefaultInstance();
  SQL_S_Scroll_Message::default_instance_->InitAsDefaultInstance();
  GSSystemMessage::default_instance_->InitAsDefaultInstance();
  GSUserHeart::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_GameServer_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_GameServer_2eproto_once_);
void protobuf_AddDesc_GameServer_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_GameServer_2eproto_once_,
                 &protobuf_AddDesc_GameServer_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_GameServer_2eproto {
  StaticDescriptorInitializer_GameServer_2eproto() {
    protobuf_AddDesc_GameServer_2eproto();
  }
} static_descriptor_initializer_GameServer_2eproto_;
#endif
bool enumUserStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int tagUserStatus::kTableIDFieldNumber;
const int tagUserStatus::kChairIDFieldNumber;
const int tagUserStatus::kUserStatusFieldNumber;
#endif  // !_MSC_VER

tagUserStatus::tagUserStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.tagUserStatus)
}

void tagUserStatus::InitAsDefaultInstance() {
}

tagUserStatus::tagUserStatus(const tagUserStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.tagUserStatus)
}

void tagUserStatus::SharedCtor() {
  _cached_size_ = 0;
  tableid_ = 0;
  chairid_ = 0;
  userstatus_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tagUserStatus::~tagUserStatus() {
  // @@protoc_insertion_point(destructor:GameServer.tagUserStatus)
  SharedDtor();
}

void tagUserStatus::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void tagUserStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const tagUserStatus& tagUserStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

tagUserStatus* tagUserStatus::default_instance_ = NULL;

tagUserStatus* tagUserStatus::New() const {
  return new tagUserStatus;
}

void tagUserStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<tagUserStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(tableid_, userstatus_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool tagUserStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.tagUserStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 tableID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tableid_)));
          set_has_tableid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_chairID;
        break;
      }

      // required int32 chairID = 2;
      case 2: {
        if (tag == 16) {
         parse_chairID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &chairid_)));
          set_has_chairid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_userStatus;
        break;
      }

      // required .GameServer.enumUserStatus userStatus = 3;
      case 3: {
        if (tag == 24) {
         parse_userStatus:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::GameServer::enumUserStatus_IsValid(value)) {
            set_userstatus(static_cast< ::GameServer::enumUserStatus >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.tagUserStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.tagUserStatus)
  return false;
#undef DO_
}

void tagUserStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.tagUserStatus)
  // required int32 tableID = 1;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tableid(), output);
  }

  // required int32 chairID = 2;
  if (has_chairid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->chairid(), output);
  }

  // required .GameServer.enumUserStatus userStatus = 3;
  if (has_userstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->userstatus(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.tagUserStatus)
}

int tagUserStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 tableID = 1;
    if (has_tableid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tableid());
    }

    // required int32 chairID = 2;
    if (has_chairid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->chairid());
    }

    // required .GameServer.enumUserStatus userStatus = 3;
    if (has_userstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->userstatus());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tagUserStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const tagUserStatus*>(&from));
}

void tagUserStatus::MergeFrom(const tagUserStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tableid()) {
      set_tableid(from.tableid());
    }
    if (from.has_chairid()) {
      set_chairid(from.chairid());
    }
    if (from.has_userstatus()) {
      set_userstatus(from.userstatus());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void tagUserStatus::CopyFrom(const tagUserStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagUserStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void tagUserStatus::Swap(tagUserStatus* other) {
  if (other != this) {
    std::swap(tableid_, other->tableid_);
    std::swap(chairid_, other->chairid_);
    std::swap(userstatus_, other->userstatus_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string tagUserStatus::GetTypeName() const {
  return "GameServer.tagUserStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int tagUserScore::kUserScoreFieldNumber;
const int tagUserScore::kWinCountFieldNumber;
const int tagUserScore::kLostCountFieldNumber;
const int tagUserScore::kDrawCountFieldNumber;
const int tagUserScore::kFleeCountFieldNumber;
#endif  // !_MSC_VER

tagUserScore::tagUserScore()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.tagUserScore)
}

void tagUserScore::InitAsDefaultInstance() {
}

tagUserScore::tagUserScore(const tagUserScore& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.tagUserScore)
}

void tagUserScore::SharedCtor() {
  _cached_size_ = 0;
  userscore_ = GOOGLE_LONGLONG(0);
  wincount_ = 0;
  lostcount_ = 0;
  drawcount_ = 0;
  fleecount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

tagUserScore::~tagUserScore() {
  // @@protoc_insertion_point(destructor:GameServer.tagUserScore)
  SharedDtor();
}

void tagUserScore::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void tagUserScore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const tagUserScore& tagUserScore::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

tagUserScore* tagUserScore::default_instance_ = NULL;

tagUserScore* tagUserScore::New() const {
  return new tagUserScore;
}

void tagUserScore::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<tagUserScore*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(userscore_, fleecount_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool tagUserScore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.tagUserScore)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 userScore = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userscore_)));
          set_has_userscore();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_winCount;
        break;
      }

      // optional int32 winCount = 2;
      case 2: {
        if (tag == 16) {
         parse_winCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wincount_)));
          set_has_wincount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_lostCount;
        break;
      }

      // optional int32 lostCount = 3;
      case 3: {
        if (tag == 24) {
         parse_lostCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lostcount_)));
          set_has_lostcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_drawCount;
        break;
      }

      // optional int32 drawCount = 4;
      case 4: {
        if (tag == 32) {
         parse_drawCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &drawcount_)));
          set_has_drawcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_fleeCount;
        break;
      }

      // optional int32 fleeCount = 5;
      case 5: {
        if (tag == 40) {
         parse_fleeCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fleecount_)));
          set_has_fleecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.tagUserScore)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.tagUserScore)
  return false;
#undef DO_
}

void tagUserScore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.tagUserScore)
  // required int64 userScore = 1;
  if (has_userscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userscore(), output);
  }

  // optional int32 winCount = 2;
  if (has_wincount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->wincount(), output);
  }

  // optional int32 lostCount = 3;
  if (has_lostcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lostcount(), output);
  }

  // optional int32 drawCount = 4;
  if (has_drawcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->drawcount(), output);
  }

  // optional int32 fleeCount = 5;
  if (has_fleecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->fleecount(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.tagUserScore)
}

int tagUserScore::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 userScore = 1;
    if (has_userscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userscore());
    }

    // optional int32 winCount = 2;
    if (has_wincount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wincount());
    }

    // optional int32 lostCount = 3;
    if (has_lostcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lostcount());
    }

    // optional int32 drawCount = 4;
    if (has_drawcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->drawcount());
    }

    // optional int32 fleeCount = 5;
    if (has_fleecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fleecount());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void tagUserScore::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const tagUserScore*>(&from));
}

void tagUserScore::MergeFrom(const tagUserScore& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userscore()) {
      set_userscore(from.userscore());
    }
    if (from.has_wincount()) {
      set_wincount(from.wincount());
    }
    if (from.has_lostcount()) {
      set_lostcount(from.lostcount());
    }
    if (from.has_drawcount()) {
      set_drawcount(from.drawcount());
    }
    if (from.has_fleecount()) {
      set_fleecount(from.fleecount());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void tagUserScore::CopyFrom(const tagUserScore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool tagUserScore::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void tagUserScore::Swap(tagUserScore* other) {
  if (other != this) {
    std::swap(userscore_, other->userscore_);
    std::swap(wincount_, other->wincount_);
    std::swap(lostcount_, other->lostcount_);
    std::swap(drawcount_, other->drawcount_);
    std::swap(fleecount_, other->fleecount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string tagUserScore::GetTypeName() const {
  return "GameServer.tagUserScore";
}


// ===================================================================

#ifndef _MSC_VER
const int GSLogonTokenID::kMerchantIDFieldNumber;
const int GSLogonTokenID::kUserIDFieldNumber;
const int GSLogonTokenID::kTokenIDFieldNumber;
const int GSLogonTokenID::kMachineIDFieldNumber;
const int GSLogonTokenID::kClientIPFieldNumber;
const int GSLogonTokenID::kDeviceTypeFieldNumber;
#endif  // !_MSC_VER

GSLogonTokenID::GSLogonTokenID()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSLogonTokenID)
}

void GSLogonTokenID::InitAsDefaultInstance() {
}

GSLogonTokenID::GSLogonTokenID(const GSLogonTokenID& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSLogonTokenID)
}

void GSLogonTokenID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  merchantid_ = 0;
  userid_ = 0;
  tokenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  machineid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  devicetype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSLogonTokenID::~GSLogonTokenID() {
  // @@protoc_insertion_point(destructor:GameServer.GSLogonTokenID)
  SharedDtor();
}

void GSLogonTokenID::SharedDtor() {
  if (tokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tokenid_;
  }
  if (machineid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete machineid_;
  }
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSLogonTokenID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSLogonTokenID& GSLogonTokenID::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSLogonTokenID* GSLogonTokenID::default_instance_ = NULL;

GSLogonTokenID* GSLogonTokenID::New() const {
  return new GSLogonTokenID;
}

void GSLogonTokenID::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GSLogonTokenID*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(merchantid_, userid_);
    if (has_tokenid()) {
      if (tokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tokenid_->clear();
      }
    }
    if (has_machineid()) {
      if (machineid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        machineid_->clear();
      }
    }
    if (has_clientip()) {
      if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        clientip_->clear();
      }
    }
    devicetype_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSLogonTokenID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSLogonTokenID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 merchantID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &merchantid_)));
          set_has_merchantid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_userID;
        break;
      }

      // required int32 userID = 2;
      case 2: {
        if (tag == 16) {
         parse_userID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tokenID;
        break;
      }

      // required string tokenID = 3;
      case 3: {
        if (tag == 26) {
         parse_tokenID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tokenid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_machineID;
        break;
      }

      // required string machineID = 4;
      case 4: {
        if (tag == 34) {
         parse_machineID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_machineid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_clientIP;
        break;
      }

      // optional string clientIP = 5;
      case 5: {
        if (tag == 42) {
         parse_clientIP:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clientip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_deviceType;
        break;
      }

      // required int32 deviceType = 6;
      case 6: {
        if (tag == 48) {
         parse_deviceType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &devicetype_)));
          set_has_devicetype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSLogonTokenID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSLogonTokenID)
  return false;
#undef DO_
}

void GSLogonTokenID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSLogonTokenID)
  // required int32 merchantID = 1;
  if (has_merchantid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->merchantid(), output);
  }

  // required int32 userID = 2;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->userid(), output);
  }

  // required string tokenID = 3;
  if (has_tokenid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->tokenid(), output);
  }

  // required string machineID = 4;
  if (has_machineid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->machineid(), output);
  }

  // optional string clientIP = 5;
  if (has_clientip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->clientip(), output);
  }

  // required int32 deviceType = 6;
  if (has_devicetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->devicetype(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSLogonTokenID)
}

int GSLogonTokenID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 merchantID = 1;
    if (has_merchantid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->merchantid());
    }

    // required int32 userID = 2;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

    // required string tokenID = 3;
    if (has_tokenid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tokenid());
    }

    // required string machineID = 4;
    if (has_machineid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->machineid());
    }

    // optional string clientIP = 5;
    if (has_clientip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clientip());
    }

    // required int32 deviceType = 6;
    if (has_devicetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->devicetype());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSLogonTokenID::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSLogonTokenID*>(&from));
}

void GSLogonTokenID::MergeFrom(const GSLogonTokenID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_merchantid()) {
      set_merchantid(from.merchantid());
    }
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_tokenid()) {
      set_tokenid(from.tokenid());
    }
    if (from.has_machineid()) {
      set_machineid(from.machineid());
    }
    if (from.has_clientip()) {
      set_clientip(from.clientip());
    }
    if (from.has_devicetype()) {
      set_devicetype(from.devicetype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSLogonTokenID::CopyFrom(const GSLogonTokenID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSLogonTokenID::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000002f) != 0x0000002f) return false;

  return true;
}

void GSLogonTokenID::Swap(GSLogonTokenID* other) {
  if (other != this) {
    std::swap(merchantid_, other->merchantid_);
    std::swap(userid_, other->userid_);
    std::swap(tokenid_, other->tokenid_);
    std::swap(machineid_, other->machineid_);
    std::swap(clientip_, other->clientip_);
    std::swap(devicetype_, other->devicetype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSLogonTokenID::GetTypeName() const {
  return "GameServer.GSLogonTokenID";
}


// ===================================================================

#ifndef _MSC_VER
const int GSLogonSuccess::kUserRightFieldNumber;
const int GSLogonSuccess::kMasterRightFieldNumber;
#endif  // !_MSC_VER

GSLogonSuccess::GSLogonSuccess()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSLogonSuccess)
}

void GSLogonSuccess::InitAsDefaultInstance() {
}

GSLogonSuccess::GSLogonSuccess(const GSLogonSuccess& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSLogonSuccess)
}

void GSLogonSuccess::SharedCtor() {
  _cached_size_ = 0;
  userright_ = GOOGLE_LONGLONG(0);
  masterright_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSLogonSuccess::~GSLogonSuccess() {
  // @@protoc_insertion_point(destructor:GameServer.GSLogonSuccess)
  SharedDtor();
}

void GSLogonSuccess::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSLogonSuccess::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSLogonSuccess& GSLogonSuccess::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSLogonSuccess* GSLogonSuccess::default_instance_ = NULL;

GSLogonSuccess* GSLogonSuccess::New() const {
  return new GSLogonSuccess;
}

void GSLogonSuccess::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GSLogonSuccess*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(userright_, masterright_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSLogonSuccess::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSLogonSuccess)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 userRight = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &userright_)));
          set_has_userright();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_masterRight;
        break;
      }

      // optional int64 masterRight = 2;
      case 2: {
        if (tag == 16) {
         parse_masterRight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &masterright_)));
          set_has_masterright();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSLogonSuccess)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSLogonSuccess)
  return false;
#undef DO_
}

void GSLogonSuccess::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSLogonSuccess)
  // optional int64 userRight = 1;
  if (has_userright()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->userright(), output);
  }

  // optional int64 masterRight = 2;
  if (has_masterright()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->masterright(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSLogonSuccess)
}

int GSLogonSuccess::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 userRight = 1;
    if (has_userright()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->userright());
    }

    // optional int64 masterRight = 2;
    if (has_masterright()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->masterright());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSLogonSuccess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSLogonSuccess*>(&from));
}

void GSLogonSuccess::MergeFrom(const GSLogonSuccess& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userright()) {
      set_userright(from.userright());
    }
    if (from.has_masterright()) {
      set_masterright(from.masterright());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSLogonSuccess::CopyFrom(const GSLogonSuccess& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSLogonSuccess::IsInitialized() const {

  return true;
}

void GSLogonSuccess::Swap(GSLogonSuccess* other) {
  if (other != this) {
    std::swap(userright_, other->userright_);
    std::swap(masterright_, other->masterright_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSLogonSuccess::GetTypeName() const {
  return "GameServer.GSLogonSuccess";
}


// ===================================================================

#ifndef _MSC_VER
const int GSLogonFinish::kResultCodeFieldNumber;
const int GSLogonFinish::kResultStrFieldNumber;
#endif  // !_MSC_VER

GSLogonFinish::GSLogonFinish()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSLogonFinish)
}

void GSLogonFinish::InitAsDefaultInstance() {
}

GSLogonFinish::GSLogonFinish(const GSLogonFinish& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSLogonFinish)
}

void GSLogonFinish::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  resultcode_ = 0;
  resultstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSLogonFinish::~GSLogonFinish() {
  // @@protoc_insertion_point(destructor:GameServer.GSLogonFinish)
  SharedDtor();
}

void GSLogonFinish::SharedDtor() {
  if (resultstr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resultstr_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSLogonFinish::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSLogonFinish& GSLogonFinish::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSLogonFinish* GSLogonFinish::default_instance_ = NULL;

GSLogonFinish* GSLogonFinish::New() const {
  return new GSLogonFinish;
}

void GSLogonFinish::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    resultcode_ = 0;
    if (has_resultstr()) {
      if (resultstr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        resultstr_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSLogonFinish::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSLogonFinish)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resultCode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &resultcode_)));
          set_has_resultcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_resultStr;
        break;
      }

      // optional string resultStr = 2;
      case 2: {
        if (tag == 18) {
         parse_resultStr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resultstr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSLogonFinish)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSLogonFinish)
  return false;
#undef DO_
}

void GSLogonFinish::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSLogonFinish)
  // optional int32 resultCode = 1;
  if (has_resultcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resultcode(), output);
  }

  // optional string resultStr = 2;
  if (has_resultstr()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->resultstr(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSLogonFinish)
}

int GSLogonFinish::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resultCode = 1;
    if (has_resultcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resultcode());
    }

    // optional string resultStr = 2;
    if (has_resultstr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resultstr());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSLogonFinish::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSLogonFinish*>(&from));
}

void GSLogonFinish::MergeFrom(const GSLogonFinish& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_resultcode()) {
      set_resultcode(from.resultcode());
    }
    if (from.has_resultstr()) {
      set_resultstr(from.resultstr());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSLogonFinish::CopyFrom(const GSLogonFinish& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSLogonFinish::IsInitialized() const {

  return true;
}

void GSLogonFinish::Swap(GSLogonFinish* other) {
  if (other != this) {
    std::swap(resultcode_, other->resultcode_);
    std::swap(resultstr_, other->resultstr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSLogonFinish::GetTypeName() const {
  return "GameServer.GSLogonFinish";
}


// ===================================================================

#ifndef _MSC_VER
const int GSLogonFailure::kErrorCodeFieldNumber;
const int GSLogonFailure::kDescribeStringFieldNumber;
#endif  // !_MSC_VER

GSLogonFailure::GSLogonFailure()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSLogonFailure)
}

void GSLogonFailure::InitAsDefaultInstance() {
}

GSLogonFailure::GSLogonFailure(const GSLogonFailure& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSLogonFailure)
}

void GSLogonFailure::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  errorcode_ = 0;
  describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSLogonFailure::~GSLogonFailure() {
  // @@protoc_insertion_point(destructor:GameServer.GSLogonFailure)
  SharedDtor();
}

void GSLogonFailure::SharedDtor() {
  if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete describestring_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSLogonFailure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSLogonFailure& GSLogonFailure::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSLogonFailure* GSLogonFailure::default_instance_ = NULL;

GSLogonFailure* GSLogonFailure::New() const {
  return new GSLogonFailure;
}

void GSLogonFailure::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    errorcode_ = 0;
    if (has_describestring()) {
      if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        describestring_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSLogonFailure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSLogonFailure)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 errorCode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &errorcode_)));
          set_has_errorcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_describeString;
        break;
      }

      // optional string describeString = 2;
      case 2: {
        if (tag == 18) {
         parse_describeString:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_describestring()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSLogonFailure)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSLogonFailure)
  return false;
#undef DO_
}

void GSLogonFailure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSLogonFailure)
  // optional int32 errorCode = 1;
  if (has_errorcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->errorcode(), output);
  }

  // optional string describeString = 2;
  if (has_describestring()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->describestring(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSLogonFailure)
}

int GSLogonFailure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 errorCode = 1;
    if (has_errorcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->errorcode());
    }

    // optional string describeString = 2;
    if (has_describestring()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->describestring());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSLogonFailure::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSLogonFailure*>(&from));
}

void GSLogonFailure::MergeFrom(const GSLogonFailure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errorcode()) {
      set_errorcode(from.errorcode());
    }
    if (from.has_describestring()) {
      set_describestring(from.describestring());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSLogonFailure::CopyFrom(const GSLogonFailure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSLogonFailure::IsInitialized() const {

  return true;
}

void GSLogonFailure::Swap(GSLogonFailure* other) {
  if (other != this) {
    std::swap(errorcode_, other->errorcode_);
    std::swap(describestring_, other->describestring_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSLogonFailure::GetTypeName() const {
  return "GameServer.GSLogonFailure";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserSitDown::kUserIDFieldNumber;
const int GSUserSitDown::kTableIDFieldNumber;
const int GSUserSitDown::kChairIDFieldNumber;
const int GSUserSitDown::kTableTokenIDFieldNumber;
#endif  // !_MSC_VER

GSUserSitDown::GSUserSitDown()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserSitDown)
}

void GSUserSitDown::InitAsDefaultInstance() {
}

GSUserSitDown::GSUserSitDown(const GSUserSitDown& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserSitDown)
}

void GSUserSitDown::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  userid_ = 0;
  tableid_ = 0;
  chairid_ = 0;
  tabletokenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserSitDown::~GSUserSitDown() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserSitDown)
  SharedDtor();
}

void GSUserSitDown::SharedDtor() {
  if (tabletokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tabletokenid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSUserSitDown::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserSitDown& GSUserSitDown::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserSitDown* GSUserSitDown::default_instance_ = NULL;

GSUserSitDown* GSUserSitDown::New() const {
  return new GSUserSitDown;
}

void GSUserSitDown::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GSUserSitDown*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(userid_, tableid_);
    chairid_ = 0;
    if (has_tabletokenid()) {
      if (tabletokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tabletokenid_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserSitDown::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserSitDown)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_tableID;
        break;
      }

      // required int32 tableID = 2;
      case 2: {
        if (tag == 16) {
         parse_tableID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tableid_)));
          set_has_tableid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_chairID;
        break;
      }

      // required int32 chairID = 3;
      case 3: {
        if (tag == 24) {
         parse_chairID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &chairid_)));
          set_has_chairid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_tableTokenID;
        break;
      }

      // optional string tableTokenID = 4;
      case 4: {
        if (tag == 34) {
         parse_tableTokenID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tabletokenid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserSitDown)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserSitDown)
  return false;
#undef DO_
}

void GSUserSitDown::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserSitDown)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  // required int32 tableID = 2;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->tableid(), output);
  }

  // required int32 chairID = 3;
  if (has_chairid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->chairid(), output);
  }

  // optional string tableTokenID = 4;
  if (has_tabletokenid()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->tabletokenid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserSitDown)
}

int GSUserSitDown::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

    // required int32 tableID = 2;
    if (has_tableid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tableid());
    }

    // required int32 chairID = 3;
    if (has_chairid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->chairid());
    }

    // optional string tableTokenID = 4;
    if (has_tabletokenid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tabletokenid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserSitDown::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserSitDown*>(&from));
}

void GSUserSitDown::MergeFrom(const GSUserSitDown& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_tableid()) {
      set_tableid(from.tableid());
    }
    if (from.has_chairid()) {
      set_chairid(from.chairid());
    }
    if (from.has_tabletokenid()) {
      set_tabletokenid(from.tabletokenid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserSitDown::CopyFrom(const GSUserSitDown& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserSitDown::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GSUserSitDown::Swap(GSUserSitDown* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(tableid_, other->tableid_);
    std::swap(chairid_, other->chairid_);
    std::swap(tabletokenid_, other->tabletokenid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserSitDown::GetTypeName() const {
  return "GameServer.GSUserSitDown";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserStandUp::kUserIDFieldNumber;
const int GSUserStandUp::kTableIDFieldNumber;
const int GSUserStandUp::kChairIDFieldNumber;
const int GSUserStandUp::kForceLeaveFieldNumber;
#endif  // !_MSC_VER

GSUserStandUp::GSUserStandUp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserStandUp)
}

void GSUserStandUp::InitAsDefaultInstance() {
}

GSUserStandUp::GSUserStandUp(const GSUserStandUp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserStandUp)
}

void GSUserStandUp::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  tableid_ = 0;
  chairid_ = 0;
  forceleave_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserStandUp::~GSUserStandUp() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserStandUp)
  SharedDtor();
}

void GSUserStandUp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSUserStandUp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserStandUp& GSUserStandUp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserStandUp* GSUserStandUp::default_instance_ = NULL;

GSUserStandUp* GSUserStandUp::New() const {
  return new GSUserStandUp;
}

void GSUserStandUp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GSUserStandUp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(userid_, forceleave_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserStandUp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserStandUp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_tableID;
        break;
      }

      // required int32 tableID = 2;
      case 2: {
        if (tag == 16) {
         parse_tableID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tableid_)));
          set_has_tableid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_chairID;
        break;
      }

      // required int32 chairID = 3;
      case 3: {
        if (tag == 24) {
         parse_chairID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &chairid_)));
          set_has_chairid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_forceLeave;
        break;
      }

      // optional bool forceLeave = 4;
      case 4: {
        if (tag == 32) {
         parse_forceLeave:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &forceleave_)));
          set_has_forceleave();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserStandUp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserStandUp)
  return false;
#undef DO_
}

void GSUserStandUp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserStandUp)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  // required int32 tableID = 2;
  if (has_tableid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->tableid(), output);
  }

  // required int32 chairID = 3;
  if (has_chairid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->chairid(), output);
  }

  // optional bool forceLeave = 4;
  if (has_forceleave()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->forceleave(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserStandUp)
}

int GSUserStandUp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

    // required int32 tableID = 2;
    if (has_tableid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tableid());
    }

    // required int32 chairID = 3;
    if (has_chairid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->chairid());
    }

    // optional bool forceLeave = 4;
    if (has_forceleave()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserStandUp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserStandUp*>(&from));
}

void GSUserStandUp::MergeFrom(const GSUserStandUp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_tableid()) {
      set_tableid(from.tableid());
    }
    if (from.has_chairid()) {
      set_chairid(from.chairid());
    }
    if (from.has_forceleave()) {
      set_forceleave(from.forceleave());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserStandUp::CopyFrom(const GSUserStandUp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserStandUp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GSUserStandUp::Swap(GSUserStandUp* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(tableid_, other->tableid_);
    std::swap(chairid_, other->chairid_);
    std::swap(forceleave_, other->forceleave_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserStandUp::GetTypeName() const {
  return "GameServer.GSUserStandUp";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserChangeTable::kUserIDFieldNumber;
#endif  // !_MSC_VER

GSUserChangeTable::GSUserChangeTable()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserChangeTable)
}

void GSUserChangeTable::InitAsDefaultInstance() {
}

GSUserChangeTable::GSUserChangeTable(const GSUserChangeTable& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserChangeTable)
}

void GSUserChangeTable::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserChangeTable::~GSUserChangeTable() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserChangeTable)
  SharedDtor();
}

void GSUserChangeTable::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSUserChangeTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserChangeTable& GSUserChangeTable::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserChangeTable* GSUserChangeTable::default_instance_ = NULL;

GSUserChangeTable* GSUserChangeTable::New() const {
  return new GSUserChangeTable;
}

void GSUserChangeTable::Clear() {
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserChangeTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserChangeTable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserChangeTable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserChangeTable)
  return false;
#undef DO_
}

void GSUserChangeTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserChangeTable)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserChangeTable)
}

int GSUserChangeTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserChangeTable::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserChangeTable*>(&from));
}

void GSUserChangeTable::MergeFrom(const GSUserChangeTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserChangeTable::CopyFrom(const GSUserChangeTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserChangeTable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GSUserChangeTable::Swap(GSUserChangeTable* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserChangeTable::GetTypeName() const {
  return "GameServer.GSUserChangeTable";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserRequestFailure::kErrorCodeFieldNumber;
const int GSUserRequestFailure::kDescribeStringFieldNumber;
#endif  // !_MSC_VER

GSUserRequestFailure::GSUserRequestFailure()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserRequestFailure)
}

void GSUserRequestFailure::InitAsDefaultInstance() {
}

GSUserRequestFailure::GSUserRequestFailure(const GSUserRequestFailure& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserRequestFailure)
}

void GSUserRequestFailure::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  errorcode_ = 0;
  describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserRequestFailure::~GSUserRequestFailure() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserRequestFailure)
  SharedDtor();
}

void GSUserRequestFailure::SharedDtor() {
  if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete describestring_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSUserRequestFailure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserRequestFailure& GSUserRequestFailure::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserRequestFailure* GSUserRequestFailure::default_instance_ = NULL;

GSUserRequestFailure* GSUserRequestFailure::New() const {
  return new GSUserRequestFailure;
}

void GSUserRequestFailure::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    errorcode_ = 0;
    if (has_describestring()) {
      if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        describestring_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserRequestFailure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserRequestFailure)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 errorCode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &errorcode_)));
          set_has_errorcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_describeString;
        break;
      }

      // optional string describeString = 2;
      case 2: {
        if (tag == 18) {
         parse_describeString:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_describestring()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserRequestFailure)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserRequestFailure)
  return false;
#undef DO_
}

void GSUserRequestFailure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserRequestFailure)
  // optional int32 errorCode = 1;
  if (has_errorcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->errorcode(), output);
  }

  // optional string describeString = 2;
  if (has_describestring()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->describestring(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserRequestFailure)
}

int GSUserRequestFailure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 errorCode = 1;
    if (has_errorcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->errorcode());
    }

    // optional string describeString = 2;
    if (has_describestring()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->describestring());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserRequestFailure::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserRequestFailure*>(&from));
}

void GSUserRequestFailure::MergeFrom(const GSUserRequestFailure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errorcode()) {
      set_errorcode(from.errorcode());
    }
    if (from.has_describestring()) {
      set_describestring(from.describestring());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserRequestFailure::CopyFrom(const GSUserRequestFailure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserRequestFailure::IsInitialized() const {

  return true;
}

void GSUserRequestFailure::Swap(GSUserRequestFailure* other) {
  if (other != this) {
    std::swap(errorcode_, other->errorcode_);
    std::swap(describestring_, other->describestring_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserRequestFailure::GetTypeName() const {
  return "GameServer.GSUserRequestFailure";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserEnter::kUserIDFieldNumber;
const int GSUserEnter::kFaceIDFieldNumber;
const int GSUserEnter::kGenderFieldNumber;
const int GSUserEnter::kUserStatusFieldNumber;
const int GSUserEnter::kScoreFieldNumber;
const int GSUserEnter::kNickNameFieldNumber;
#endif  // !_MSC_VER

GSUserEnter::GSUserEnter()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserEnter)
}

void GSUserEnter::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  userstatus_ = const_cast< ::GameServer::tagUserStatus*>(
      ::GameServer::tagUserStatus::internal_default_instance());
#else
  userstatus_ = const_cast< ::GameServer::tagUserStatus*>(&::GameServer::tagUserStatus::default_instance());
#endif
}

GSUserEnter::GSUserEnter(const GSUserEnter& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserEnter)
}

void GSUserEnter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  userid_ = 0;
  faceid_ = 0;
  gender_ = 0;
  userstatus_ = NULL;
  score_ = GOOGLE_LONGLONG(0);
  nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserEnter::~GSUserEnter() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserEnter)
  SharedDtor();
}

void GSUserEnter::SharedDtor() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete userstatus_;
  }
}

void GSUserEnter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserEnter& GSUserEnter::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserEnter* GSUserEnter::default_instance_ = NULL;

GSUserEnter* GSUserEnter::New() const {
  return new GSUserEnter;
}

void GSUserEnter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GSUserEnter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(userid_, faceid_);
    gender_ = 0;
    if (has_userstatus()) {
      if (userstatus_ != NULL) userstatus_->::GameServer::tagUserStatus::Clear();
    }
    score_ = GOOGLE_LONGLONG(0);
    if (has_nickname()) {
      if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        nickname_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserEnter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserEnter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_faceID;
        break;
      }

      // optional int32 faceID = 2;
      case 2: {
        if (tag == 16) {
         parse_faceID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &faceid_)));
          set_has_faceid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_gender;
        break;
      }

      // optional int32 gender = 3;
      case 3: {
        if (tag == 24) {
         parse_gender:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gender_)));
          set_has_gender();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_userStatus;
        break;
      }

      // required .GameServer.tagUserStatus userStatus = 4;
      case 4: {
        if (tag == 34) {
         parse_userStatus:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_userstatus()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_score;
        break;
      }

      // required int64 score = 5;
      case 5: {
        if (tag == 40) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_nickName;
        break;
      }

      // optional string nickName = 6;
      case 6: {
        if (tag == 50) {
         parse_nickName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserEnter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserEnter)
  return false;
#undef DO_
}

void GSUserEnter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserEnter)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  // optional int32 faceID = 2;
  if (has_faceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->faceid(), output);
  }

  // optional int32 gender = 3;
  if (has_gender()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->gender(), output);
  }

  // required .GameServer.tagUserStatus userStatus = 4;
  if (has_userstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->userstatus(), output);
  }

  // required int64 score = 5;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->score(), output);
  }

  // optional string nickName = 6;
  if (has_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->nickname(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserEnter)
}

int GSUserEnter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

    // optional int32 faceID = 2;
    if (has_faceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->faceid());
    }

    // optional int32 gender = 3;
    if (has_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gender());
    }

    // required .GameServer.tagUserStatus userStatus = 4;
    if (has_userstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->userstatus());
    }

    // required int64 score = 5;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->score());
    }

    // optional string nickName = 6;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserEnter::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserEnter*>(&from));
}

void GSUserEnter::MergeFrom(const GSUserEnter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_faceid()) {
      set_faceid(from.faceid());
    }
    if (from.has_gender()) {
      set_gender(from.gender());
    }
    if (from.has_userstatus()) {
      mutable_userstatus()->::GameServer::tagUserStatus::MergeFrom(from.userstatus());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_nickname()) {
      set_nickname(from.nickname());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserEnter::CopyFrom(const GSUserEnter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserEnter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000019) != 0x00000019) return false;

  if (has_userstatus()) {
    if (!this->userstatus().IsInitialized()) return false;
  }
  return true;
}

void GSUserEnter::Swap(GSUserEnter* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(faceid_, other->faceid_);
    std::swap(gender_, other->gender_);
    std::swap(userstatus_, other->userstatus_);
    std::swap(score_, other->score_);
    std::swap(nickname_, other->nickname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserEnter::GetTypeName() const {
  return "GameServer.GSUserEnter";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserLeave::kUserIDFieldNumber;
#endif  // !_MSC_VER

GSUserLeave::GSUserLeave()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserLeave)
}

void GSUserLeave::InitAsDefaultInstance() {
}

GSUserLeave::GSUserLeave(const GSUserLeave& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserLeave)
}

void GSUserLeave::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserLeave::~GSUserLeave() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserLeave)
  SharedDtor();
}

void GSUserLeave::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSUserLeave::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserLeave& GSUserLeave::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserLeave* GSUserLeave::default_instance_ = NULL;

GSUserLeave* GSUserLeave::New() const {
  return new GSUserLeave;
}

void GSUserLeave::Clear() {
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserLeave::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserLeave)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserLeave)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserLeave)
  return false;
#undef DO_
}

void GSUserLeave::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserLeave)
  // optional int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserLeave)
}

int GSUserLeave::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserLeave::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserLeave*>(&from));
}

void GSUserLeave::MergeFrom(const GSUserLeave& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserLeave::CopyFrom(const GSUserLeave& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserLeave::IsInitialized() const {

  return true;
}

void GSUserLeave::Swap(GSUserLeave* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserLeave::GetTypeName() const {
  return "GameServer.GSUserLeave";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserStatus::kUserIDFieldNumber;
const int GSUserStatus::kUserStatusFieldNumber;
#endif  // !_MSC_VER

GSUserStatus::GSUserStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserStatus)
}

void GSUserStatus::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  userstatus_ = const_cast< ::GameServer::tagUserStatus*>(
      ::GameServer::tagUserStatus::internal_default_instance());
#else
  userstatus_ = const_cast< ::GameServer::tagUserStatus*>(&::GameServer::tagUserStatus::default_instance());
#endif
}

GSUserStatus::GSUserStatus(const GSUserStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserStatus)
}

void GSUserStatus::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  userstatus_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserStatus::~GSUserStatus() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserStatus)
  SharedDtor();
}

void GSUserStatus::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete userstatus_;
  }
}

void GSUserStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserStatus& GSUserStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserStatus* GSUserStatus::default_instance_ = NULL;

GSUserStatus* GSUserStatus::New() const {
  return new GSUserStatus;
}

void GSUserStatus::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    userid_ = 0;
    if (has_userstatus()) {
      if (userstatus_ != NULL) userstatus_->::GameServer::tagUserStatus::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_userStatus;
        break;
      }

      // required .GameServer.tagUserStatus userStatus = 2;
      case 2: {
        if (tag == 18) {
         parse_userStatus:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_userstatus()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserStatus)
  return false;
#undef DO_
}

void GSUserStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserStatus)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  // required .GameServer.tagUserStatus userStatus = 2;
  if (has_userstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->userstatus(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserStatus)
}

int GSUserStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

    // required .GameServer.tagUserStatus userStatus = 2;
    if (has_userstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->userstatus());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserStatus*>(&from));
}

void GSUserStatus::MergeFrom(const GSUserStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_userstatus()) {
      mutable_userstatus()->::GameServer::tagUserStatus::MergeFrom(from.userstatus());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserStatus::CopyFrom(const GSUserStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_userstatus()) {
    if (!this->userstatus().IsInitialized()) return false;
  }
  return true;
}

void GSUserStatus::Swap(GSUserStatus* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(userstatus_, other->userstatus_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserStatus::GetTypeName() const {
  return "GameServer.GSUserStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserScore::kUserIDFieldNumber;
const int GSUserScore::kUserScoreFieldNumber;
#endif  // !_MSC_VER

GSUserScore::GSUserScore()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserScore)
}

void GSUserScore::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  userscore_ = const_cast< ::GameServer::tagUserScore*>(
      ::GameServer::tagUserScore::internal_default_instance());
#else
  userscore_ = const_cast< ::GameServer::tagUserScore*>(&::GameServer::tagUserScore::default_instance());
#endif
}

GSUserScore::GSUserScore(const GSUserScore& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserScore)
}

void GSUserScore::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  userscore_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserScore::~GSUserScore() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserScore)
  SharedDtor();
}

void GSUserScore::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete userscore_;
  }
}

void GSUserScore::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserScore& GSUserScore::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserScore* GSUserScore::default_instance_ = NULL;

GSUserScore* GSUserScore::New() const {
  return new GSUserScore;
}

void GSUserScore::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    userid_ = 0;
    if (has_userscore()) {
      if (userscore_ != NULL) userscore_->::GameServer::tagUserScore::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserScore::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserScore)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_userScore;
        break;
      }

      // required .GameServer.tagUserScore userScore = 2;
      case 2: {
        if (tag == 18) {
         parse_userScore:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_userscore()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserScore)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserScore)
  return false;
#undef DO_
}

void GSUserScore::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserScore)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  // required .GameServer.tagUserScore userScore = 2;
  if (has_userscore()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->userscore(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserScore)
}

int GSUserScore::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

    // required .GameServer.tagUserScore userScore = 2;
    if (has_userscore()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->userscore());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserScore::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserScore*>(&from));
}

void GSUserScore::MergeFrom(const GSUserScore& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_userscore()) {
      mutable_userscore()->::GameServer::tagUserScore::MergeFrom(from.userscore());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserScore::CopyFrom(const GSUserScore& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserScore::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_userscore()) {
    if (!this->userscore().IsInitialized()) return false;
  }
  return true;
}

void GSUserScore::Swap(GSUserScore* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(userscore_, other->userscore_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserScore::GetTypeName() const {
  return "GameServer.GSUserScore";
}


// ===================================================================

#ifndef _MSC_VER
const int GSGameOption::kUserIDFieldNumber;
const int GSGameOption::kAllowLookonFieldNumber;
#endif  // !_MSC_VER

GSGameOption::GSGameOption()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSGameOption)
}

void GSGameOption::InitAsDefaultInstance() {
}

GSGameOption::GSGameOption(const GSGameOption& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSGameOption)
}

void GSGameOption::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  allowlookon_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSGameOption::~GSGameOption() {
  // @@protoc_insertion_point(destructor:GameServer.GSGameOption)
  SharedDtor();
}

void GSGameOption::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSGameOption::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSGameOption& GSGameOption::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSGameOption* GSGameOption::default_instance_ = NULL;

GSGameOption* GSGameOption::New() const {
  return new GSGameOption;
}

void GSGameOption::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GSGameOption*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(userid_, allowlookon_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSGameOption::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSGameOption)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_allowLookon;
        break;
      }

      // optional bool allowLookon = 2;
      case 2: {
        if (tag == 16) {
         parse_allowLookon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allowlookon_)));
          set_has_allowlookon();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSGameOption)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSGameOption)
  return false;
#undef DO_
}

void GSGameOption::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSGameOption)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  // optional bool allowLookon = 2;
  if (has_allowlookon()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->allowlookon(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSGameOption)
}

int GSGameOption::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

    // optional bool allowLookon = 2;
    if (has_allowlookon()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSGameOption::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSGameOption*>(&from));
}

void GSGameOption::MergeFrom(const GSGameOption& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_allowlookon()) {
      set_allowlookon(from.allowlookon());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSGameOption::CopyFrom(const GSGameOption& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSGameOption::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GSGameOption::Swap(GSGameOption* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(allowlookon_, other->allowlookon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSGameOption::GetTypeName() const {
  return "GameServer.GSGameOption";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserReady::kUserIDFieldNumber;
#endif  // !_MSC_VER

GSUserReady::GSUserReady()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserReady)
}

void GSUserReady::InitAsDefaultInstance() {
}

GSUserReady::GSUserReady(const GSUserReady& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserReady)
}

void GSUserReady::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserReady::~GSUserReady() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserReady)
  SharedDtor();
}

void GSUserReady::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSUserReady::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserReady& GSUserReady::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserReady* GSUserReady::default_instance_ = NULL;

GSUserReady* GSUserReady::New() const {
  return new GSUserReady;
}

void GSUserReady::Clear() {
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserReady::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserReady)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserReady)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserReady)
  return false;
#undef DO_
}

void GSUserReady::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserReady)
  // required int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserReady)
}

int GSUserReady::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserReady::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserReady*>(&from));
}

void GSUserReady::MergeFrom(const GSUserReady& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserReady::CopyFrom(const GSUserReady& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserReady::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GSUserReady::Swap(GSUserReady* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserReady::GetTypeName() const {
  return "GameServer.GSUserReady";
}


// ===================================================================

#ifndef _MSC_VER
const int Proto_GameStatus::kCbGameStatusFieldNumber;
#endif  // !_MSC_VER

Proto_GameStatus::Proto_GameStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.Proto_GameStatus)
}

void Proto_GameStatus::InitAsDefaultInstance() {
}

Proto_GameStatus::Proto_GameStatus(const Proto_GameStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.Proto_GameStatus)
}

void Proto_GameStatus::SharedCtor() {
  _cached_size_ = 0;
  cbgamestatus_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Proto_GameStatus::~Proto_GameStatus() {
  // @@protoc_insertion_point(destructor:GameServer.Proto_GameStatus)
  SharedDtor();
}

void Proto_GameStatus::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Proto_GameStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Proto_GameStatus& Proto_GameStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

Proto_GameStatus* Proto_GameStatus::default_instance_ = NULL;

Proto_GameStatus* Proto_GameStatus::New() const {
  return new Proto_GameStatus;
}

void Proto_GameStatus::Clear() {
  cbgamestatus_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Proto_GameStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.Proto_GameStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 cbGameStatus = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cbgamestatus_)));
          set_has_cbgamestatus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.Proto_GameStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.Proto_GameStatus)
  return false;
#undef DO_
}

void Proto_GameStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.Proto_GameStatus)
  // required int32 cbGameStatus = 1;
  if (has_cbgamestatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cbgamestatus(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.Proto_GameStatus)
}

int Proto_GameStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 cbGameStatus = 1;
    if (has_cbgamestatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cbgamestatus());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Proto_GameStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Proto_GameStatus*>(&from));
}

void Proto_GameStatus::MergeFrom(const Proto_GameStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cbgamestatus()) {
      set_cbgamestatus(from.cbgamestatus());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Proto_GameStatus::CopyFrom(const Proto_GameStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proto_GameStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Proto_GameStatus::Swap(Proto_GameStatus* other) {
  if (other != this) {
    std::swap(cbgamestatus_, other->cbgamestatus_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Proto_GameStatus::GetTypeName() const {
  return "GameServer.Proto_GameStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int SQL_S_Scroll_Message::kBMessageTypeFieldNumber;
const int SQL_S_Scroll_Message::kSScrollMsgFieldNumber;
#endif  // !_MSC_VER

SQL_S_Scroll_Message::SQL_S_Scroll_Message()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.SQL_S_Scroll_Message)
}

void SQL_S_Scroll_Message::InitAsDefaultInstance() {
}

SQL_S_Scroll_Message::SQL_S_Scroll_Message(const SQL_S_Scroll_Message& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.SQL_S_Scroll_Message)
}

void SQL_S_Scroll_Message::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  bmessagetype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SQL_S_Scroll_Message::~SQL_S_Scroll_Message() {
  // @@protoc_insertion_point(destructor:GameServer.SQL_S_Scroll_Message)
  SharedDtor();
}

void SQL_S_Scroll_Message::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SQL_S_Scroll_Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SQL_S_Scroll_Message& SQL_S_Scroll_Message::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

SQL_S_Scroll_Message* SQL_S_Scroll_Message::default_instance_ = NULL;

SQL_S_Scroll_Message* SQL_S_Scroll_Message::New() const {
  return new SQL_S_Scroll_Message;
}

void SQL_S_Scroll_Message::Clear() {
  bmessagetype_ = 0;
  sscrollmsg_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SQL_S_Scroll_Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.SQL_S_Scroll_Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 bMessageType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bmessagetype_)));
          set_has_bmessagetype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sScrollMsg;
        break;
      }

      // repeated string sScrollMsg = 2;
      case 2: {
        if (tag == 18) {
         parse_sScrollMsg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_sscrollmsg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sScrollMsg;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.SQL_S_Scroll_Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.SQL_S_Scroll_Message)
  return false;
#undef DO_
}

void SQL_S_Scroll_Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.SQL_S_Scroll_Message)
  // required int32 bMessageType = 1;
  if (has_bmessagetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bmessagetype(), output);
  }

  // repeated string sScrollMsg = 2;
  for (int i = 0; i < this->sscrollmsg_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->sscrollmsg(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.SQL_S_Scroll_Message)
}

int SQL_S_Scroll_Message::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 bMessageType = 1;
    if (has_bmessagetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bmessagetype());
    }

  }
  // repeated string sScrollMsg = 2;
  total_size += 1 * this->sscrollmsg_size();
  for (int i = 0; i < this->sscrollmsg_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->sscrollmsg(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SQL_S_Scroll_Message::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SQL_S_Scroll_Message*>(&from));
}

void SQL_S_Scroll_Message::MergeFrom(const SQL_S_Scroll_Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  sscrollmsg_.MergeFrom(from.sscrollmsg_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bmessagetype()) {
      set_bmessagetype(from.bmessagetype());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SQL_S_Scroll_Message::CopyFrom(const SQL_S_Scroll_Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SQL_S_Scroll_Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SQL_S_Scroll_Message::Swap(SQL_S_Scroll_Message* other) {
  if (other != this) {
    std::swap(bmessagetype_, other->bmessagetype_);
    sscrollmsg_.Swap(&other->sscrollmsg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SQL_S_Scroll_Message::GetTypeName() const {
  return "GameServer.SQL_S_Scroll_Message";
}


// ===================================================================

#ifndef _MSC_VER
const int GSSystemMessage::kMessageTypeFieldNumber;
const int GSSystemMessage::kMessageStringFieldNumber;
#endif  // !_MSC_VER

GSSystemMessage::GSSystemMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSSystemMessage)
}

void GSSystemMessage::InitAsDefaultInstance() {
}

GSSystemMessage::GSSystemMessage(const GSSystemMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSSystemMessage)
}

void GSSystemMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  messagetype_ = 0;
  messagestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSSystemMessage::~GSSystemMessage() {
  // @@protoc_insertion_point(destructor:GameServer.GSSystemMessage)
  SharedDtor();
}

void GSSystemMessage::SharedDtor() {
  if (messagestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messagestring_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSSystemMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSSystemMessage& GSSystemMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSSystemMessage* GSSystemMessage::default_instance_ = NULL;

GSSystemMessage* GSSystemMessage::New() const {
  return new GSSystemMessage;
}

void GSSystemMessage::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    messagetype_ = 0;
    if (has_messagestring()) {
      if (messagestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        messagestring_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSSystemMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSSystemMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 messageType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &messagetype_)));
          set_has_messagetype();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_messageString;
        break;
      }

      // required string messageString = 2;
      case 2: {
        if (tag == 18) {
         parse_messageString:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_messagestring()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSSystemMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSSystemMessage)
  return false;
#undef DO_
}

void GSSystemMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSSystemMessage)
  // required int32 messageType = 1;
  if (has_messagetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->messagetype(), output);
  }

  // required string messageString = 2;
  if (has_messagestring()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->messagestring(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSSystemMessage)
}

int GSSystemMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 messageType = 1;
    if (has_messagetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->messagetype());
    }

    // required string messageString = 2;
    if (has_messagestring()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->messagestring());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSSystemMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSSystemMessage*>(&from));
}

void GSSystemMessage::MergeFrom(const GSSystemMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_messagetype()) {
      set_messagetype(from.messagetype());
    }
    if (from.has_messagestring()) {
      set_messagestring(from.messagestring());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSSystemMessage::CopyFrom(const GSSystemMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSSystemMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GSSystemMessage::Swap(GSSystemMessage* other) {
  if (other != this) {
    std::swap(messagetype_, other->messagetype_);
    std::swap(messagestring_, other->messagestring_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSSystemMessage::GetTypeName() const {
  return "GameServer.GSSystemMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int GSUserHeart::kUserIDFieldNumber;
#endif  // !_MSC_VER

GSUserHeart::GSUserHeart()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:GameServer.GSUserHeart)
}

void GSUserHeart::InitAsDefaultInstance() {
}

GSUserHeart::GSUserHeart(const GSUserHeart& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:GameServer.GSUserHeart)
}

void GSUserHeart::SharedCtor() {
  _cached_size_ = 0;
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GSUserHeart::~GSUserHeart() {
  // @@protoc_insertion_point(destructor:GameServer.GSUserHeart)
  SharedDtor();
}

void GSUserHeart::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GSUserHeart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GSUserHeart& GSUserHeart::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_GameServer_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_GameServer_2eproto();
#endif
  return *default_instance_;
}

GSUserHeart* GSUserHeart::default_instance_ = NULL;

GSUserHeart* GSUserHeart::New() const {
  return new GSUserHeart;
}

void GSUserHeart::Clear() {
  userid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GSUserHeart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:GameServer.GSUserHeart)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 userID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:GameServer.GSUserHeart)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:GameServer.GSUserHeart)
  return false;
#undef DO_
}

void GSUserHeart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:GameServer.GSUserHeart)
  // optional int32 userID = 1;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->userid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:GameServer.GSUserHeart)
}

int GSUserHeart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 userID = 1;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->userid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GSUserHeart::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GSUserHeart*>(&from));
}

void GSUserHeart::MergeFrom(const GSUserHeart& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GSUserHeart::CopyFrom(const GSUserHeart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GSUserHeart::IsInitialized() const {

  return true;
}

void GSUserHeart::Swap(GSUserHeart* other) {
  if (other != this) {
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GSUserHeart::GetTypeName() const {
  return "GameServer.GSUserHeart";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace GameServer

// @@protoc_insertion_point(global_scope)
