// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameServer.proto

#ifndef PROTOBUF_GameServer_2eproto__INCLUDED
#define PROTOBUF_GameServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace GameServer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GameServer_2eproto();
void protobuf_AssignDesc_GameServer_2eproto();
void protobuf_ShutdownFile_GameServer_2eproto();

class tagUserStatus;
class tagUserScore;
class GSLogonTokenID;
class GSLogonSuccess;
class GSLogonFinish;
class GSLogonFailure;
class GSUserSitDown;
class GSUserStandUp;
class GSUserChangeTable;
class GSUserRequestFailure;
class GSUserEnter;
class GSUserLeave;
class GSUserStatus;
class GSUserScore;
class GSGameOption;
class GSUserReady;
class Proto_GameStatus;
class SQL_S_Scroll_Message;
class GSSystemMessage;
class GSUserHeart;

enum enumUserStatus {
  enumUserStatus_US_NULL = 0,
  enumUserStatus_US_FREE = 1,
  enumUserStatus_US_SIT = 2,
  enumUserStatus_US_READY = 3,
  enumUserStatus_US_LOOKON = 4,
  enumUserStatus_US_PLAYING = 5,
  enumUserStatus_US_OFFLINE = 6
};
bool enumUserStatus_IsValid(int value);
const enumUserStatus enumUserStatus_MIN = enumUserStatus_US_NULL;
const enumUserStatus enumUserStatus_MAX = enumUserStatus_US_OFFLINE;
const int enumUserStatus_ARRAYSIZE = enumUserStatus_MAX + 1;

// ===================================================================

class tagUserStatus : public ::google::protobuf::MessageLite {
 public:
  tagUserStatus();
  virtual ~tagUserStatus();

  tagUserStatus(const tagUserStatus& from);

  inline tagUserStatus& operator=(const tagUserStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const tagUserStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const tagUserStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(tagUserStatus* other);

  // implements Message ----------------------------------------------

  tagUserStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const tagUserStatus& from);
  void MergeFrom(const tagUserStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tableID = 1;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableIDFieldNumber = 1;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // required int32 chairID = 2;
  inline bool has_chairid() const;
  inline void clear_chairid();
  static const int kChairIDFieldNumber = 2;
  inline ::google::protobuf::int32 chairid() const;
  inline void set_chairid(::google::protobuf::int32 value);

  // required .GameServer.enumUserStatus userStatus = 3;
  inline bool has_userstatus() const;
  inline void clear_userstatus();
  static const int kUserStatusFieldNumber = 3;
  inline ::GameServer::enumUserStatus userstatus() const;
  inline void set_userstatus(::GameServer::enumUserStatus value);

  // @@protoc_insertion_point(class_scope:GameServer.tagUserStatus)
 private:
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_chairid();
  inline void clear_has_chairid();
  inline void set_has_userstatus();
  inline void clear_has_userstatus();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 tableid_;
  ::google::protobuf::int32 chairid_;
  int userstatus_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static tagUserStatus* default_instance_;
};
// -------------------------------------------------------------------

class tagUserScore : public ::google::protobuf::MessageLite {
 public:
  tagUserScore();
  virtual ~tagUserScore();

  tagUserScore(const tagUserScore& from);

  inline tagUserScore& operator=(const tagUserScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const tagUserScore& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const tagUserScore* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(tagUserScore* other);

  // implements Message ----------------------------------------------

  tagUserScore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const tagUserScore& from);
  void MergeFrom(const tagUserScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 userScore = 1;
  inline bool has_userscore() const;
  inline void clear_userscore();
  static const int kUserScoreFieldNumber = 1;
  inline ::google::protobuf::int64 userscore() const;
  inline void set_userscore(::google::protobuf::int64 value);

  // optional int32 winCount = 2;
  inline bool has_wincount() const;
  inline void clear_wincount();
  static const int kWinCountFieldNumber = 2;
  inline ::google::protobuf::int32 wincount() const;
  inline void set_wincount(::google::protobuf::int32 value);

  // optional int32 lostCount = 3;
  inline bool has_lostcount() const;
  inline void clear_lostcount();
  static const int kLostCountFieldNumber = 3;
  inline ::google::protobuf::int32 lostcount() const;
  inline void set_lostcount(::google::protobuf::int32 value);

  // optional int32 drawCount = 4;
  inline bool has_drawcount() const;
  inline void clear_drawcount();
  static const int kDrawCountFieldNumber = 4;
  inline ::google::protobuf::int32 drawcount() const;
  inline void set_drawcount(::google::protobuf::int32 value);

  // optional int32 fleeCount = 5;
  inline bool has_fleecount() const;
  inline void clear_fleecount();
  static const int kFleeCountFieldNumber = 5;
  inline ::google::protobuf::int32 fleecount() const;
  inline void set_fleecount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServer.tagUserScore)
 private:
  inline void set_has_userscore();
  inline void clear_has_userscore();
  inline void set_has_wincount();
  inline void clear_has_wincount();
  inline void set_has_lostcount();
  inline void clear_has_lostcount();
  inline void set_has_drawcount();
  inline void clear_has_drawcount();
  inline void set_has_fleecount();
  inline void clear_has_fleecount();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 userscore_;
  ::google::protobuf::int32 wincount_;
  ::google::protobuf::int32 lostcount_;
  ::google::protobuf::int32 drawcount_;
  ::google::protobuf::int32 fleecount_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static tagUserScore* default_instance_;
};
// -------------------------------------------------------------------

class GSLogonTokenID : public ::google::protobuf::MessageLite {
 public:
  GSLogonTokenID();
  virtual ~GSLogonTokenID();

  GSLogonTokenID(const GSLogonTokenID& from);

  inline GSLogonTokenID& operator=(const GSLogonTokenID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSLogonTokenID& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSLogonTokenID* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSLogonTokenID* other);

  // implements Message ----------------------------------------------

  GSLogonTokenID* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSLogonTokenID& from);
  void MergeFrom(const GSLogonTokenID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 merchantID = 1;
  inline bool has_merchantid() const;
  inline void clear_merchantid();
  static const int kMerchantIDFieldNumber = 1;
  inline ::google::protobuf::int32 merchantid() const;
  inline void set_merchantid(::google::protobuf::int32 value);

  // required int32 userID = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 2;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required string tokenID = 3;
  inline bool has_tokenid() const;
  inline void clear_tokenid();
  static const int kTokenIDFieldNumber = 3;
  inline const ::std::string& tokenid() const;
  inline void set_tokenid(const ::std::string& value);
  inline void set_tokenid(const char* value);
  inline void set_tokenid(const char* value, size_t size);
  inline ::std::string* mutable_tokenid();
  inline ::std::string* release_tokenid();
  inline void set_allocated_tokenid(::std::string* tokenid);

  // required string machineID = 4;
  inline bool has_machineid() const;
  inline void clear_machineid();
  static const int kMachineIDFieldNumber = 4;
  inline const ::std::string& machineid() const;
  inline void set_machineid(const ::std::string& value);
  inline void set_machineid(const char* value);
  inline void set_machineid(const char* value, size_t size);
  inline ::std::string* mutable_machineid();
  inline ::std::string* release_machineid();
  inline void set_allocated_machineid(::std::string* machineid);

  // optional string clientIP = 5;
  inline bool has_clientip() const;
  inline void clear_clientip();
  static const int kClientIPFieldNumber = 5;
  inline const ::std::string& clientip() const;
  inline void set_clientip(const ::std::string& value);
  inline void set_clientip(const char* value);
  inline void set_clientip(const char* value, size_t size);
  inline ::std::string* mutable_clientip();
  inline ::std::string* release_clientip();
  inline void set_allocated_clientip(::std::string* clientip);

  // required int32 deviceType = 6;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 6;
  inline ::google::protobuf::int32 devicetype() const;
  inline void set_devicetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServer.GSLogonTokenID)
 private:
  inline void set_has_merchantid();
  inline void clear_has_merchantid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_tokenid();
  inline void clear_has_tokenid();
  inline void set_has_machineid();
  inline void clear_has_machineid();
  inline void set_has_clientip();
  inline void clear_has_clientip();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 merchantid_;
  ::google::protobuf::int32 userid_;
  ::std::string* tokenid_;
  ::std::string* machineid_;
  ::std::string* clientip_;
  ::google::protobuf::int32 devicetype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSLogonTokenID* default_instance_;
};
// -------------------------------------------------------------------

class GSLogonSuccess : public ::google::protobuf::MessageLite {
 public:
  GSLogonSuccess();
  virtual ~GSLogonSuccess();

  GSLogonSuccess(const GSLogonSuccess& from);

  inline GSLogonSuccess& operator=(const GSLogonSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSLogonSuccess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSLogonSuccess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSLogonSuccess* other);

  // implements Message ----------------------------------------------

  GSLogonSuccess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSLogonSuccess& from);
  void MergeFrom(const GSLogonSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 userRight = 1;
  inline bool has_userright() const;
  inline void clear_userright();
  static const int kUserRightFieldNumber = 1;
  inline ::google::protobuf::int64 userright() const;
  inline void set_userright(::google::protobuf::int64 value);

  // optional int64 masterRight = 2;
  inline bool has_masterright() const;
  inline void clear_masterright();
  static const int kMasterRightFieldNumber = 2;
  inline ::google::protobuf::int64 masterright() const;
  inline void set_masterright(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:GameServer.GSLogonSuccess)
 private:
  inline void set_has_userright();
  inline void clear_has_userright();
  inline void set_has_masterright();
  inline void clear_has_masterright();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 userright_;
  ::google::protobuf::int64 masterright_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSLogonSuccess* default_instance_;
};
// -------------------------------------------------------------------

class GSLogonFinish : public ::google::protobuf::MessageLite {
 public:
  GSLogonFinish();
  virtual ~GSLogonFinish();

  GSLogonFinish(const GSLogonFinish& from);

  inline GSLogonFinish& operator=(const GSLogonFinish& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSLogonFinish& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSLogonFinish* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSLogonFinish* other);

  // implements Message ----------------------------------------------

  GSLogonFinish* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSLogonFinish& from);
  void MergeFrom(const GSLogonFinish& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 resultCode = 1;
  inline bool has_resultcode() const;
  inline void clear_resultcode();
  static const int kResultCodeFieldNumber = 1;
  inline ::google::protobuf::int32 resultcode() const;
  inline void set_resultcode(::google::protobuf::int32 value);

  // optional string resultStr = 2;
  inline bool has_resultstr() const;
  inline void clear_resultstr();
  static const int kResultStrFieldNumber = 2;
  inline const ::std::string& resultstr() const;
  inline void set_resultstr(const ::std::string& value);
  inline void set_resultstr(const char* value);
  inline void set_resultstr(const char* value, size_t size);
  inline ::std::string* mutable_resultstr();
  inline ::std::string* release_resultstr();
  inline void set_allocated_resultstr(::std::string* resultstr);

  // @@protoc_insertion_point(class_scope:GameServer.GSLogonFinish)
 private:
  inline void set_has_resultcode();
  inline void clear_has_resultcode();
  inline void set_has_resultstr();
  inline void clear_has_resultstr();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* resultstr_;
  ::google::protobuf::int32 resultcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSLogonFinish* default_instance_;
};
// -------------------------------------------------------------------

class GSLogonFailure : public ::google::protobuf::MessageLite {
 public:
  GSLogonFailure();
  virtual ~GSLogonFailure();

  GSLogonFailure(const GSLogonFailure& from);

  inline GSLogonFailure& operator=(const GSLogonFailure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSLogonFailure& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSLogonFailure* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSLogonFailure* other);

  // implements Message ----------------------------------------------

  GSLogonFailure* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSLogonFailure& from);
  void MergeFrom(const GSLogonFailure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // optional string describeString = 2;
  inline bool has_describestring() const;
  inline void clear_describestring();
  static const int kDescribeStringFieldNumber = 2;
  inline const ::std::string& describestring() const;
  inline void set_describestring(const ::std::string& value);
  inline void set_describestring(const char* value);
  inline void set_describestring(const char* value, size_t size);
  inline ::std::string* mutable_describestring();
  inline ::std::string* release_describestring();
  inline void set_allocated_describestring(::std::string* describestring);

  // @@protoc_insertion_point(class_scope:GameServer.GSLogonFailure)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_describestring();
  inline void clear_has_describestring();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* describestring_;
  ::google::protobuf::int32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSLogonFailure* default_instance_;
};
// -------------------------------------------------------------------

class GSUserSitDown : public ::google::protobuf::MessageLite {
 public:
  GSUserSitDown();
  virtual ~GSUserSitDown();

  GSUserSitDown(const GSUserSitDown& from);

  inline GSUserSitDown& operator=(const GSUserSitDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserSitDown& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserSitDown* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserSitDown* other);

  // implements Message ----------------------------------------------

  GSUserSitDown* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserSitDown& from);
  void MergeFrom(const GSUserSitDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required int32 tableID = 2;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableIDFieldNumber = 2;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // required int32 chairID = 3;
  inline bool has_chairid() const;
  inline void clear_chairid();
  static const int kChairIDFieldNumber = 3;
  inline ::google::protobuf::int32 chairid() const;
  inline void set_chairid(::google::protobuf::int32 value);

  // optional string tableTokenID = 4;
  inline bool has_tabletokenid() const;
  inline void clear_tabletokenid();
  static const int kTableTokenIDFieldNumber = 4;
  inline const ::std::string& tabletokenid() const;
  inline void set_tabletokenid(const ::std::string& value);
  inline void set_tabletokenid(const char* value);
  inline void set_tabletokenid(const char* value, size_t size);
  inline ::std::string* mutable_tabletokenid();
  inline ::std::string* release_tabletokenid();
  inline void set_allocated_tabletokenid(::std::string* tabletokenid);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserSitDown)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_chairid();
  inline void clear_has_chairid();
  inline void set_has_tabletokenid();
  inline void clear_has_tabletokenid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 tableid_;
  ::std::string* tabletokenid_;
  ::google::protobuf::int32 chairid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserSitDown* default_instance_;
};
// -------------------------------------------------------------------

class GSUserStandUp : public ::google::protobuf::MessageLite {
 public:
  GSUserStandUp();
  virtual ~GSUserStandUp();

  GSUserStandUp(const GSUserStandUp& from);

  inline GSUserStandUp& operator=(const GSUserStandUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserStandUp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserStandUp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserStandUp* other);

  // implements Message ----------------------------------------------

  GSUserStandUp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserStandUp& from);
  void MergeFrom(const GSUserStandUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required int32 tableID = 2;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableIDFieldNumber = 2;
  inline ::google::protobuf::int32 tableid() const;
  inline void set_tableid(::google::protobuf::int32 value);

  // required int32 chairID = 3;
  inline bool has_chairid() const;
  inline void clear_chairid();
  static const int kChairIDFieldNumber = 3;
  inline ::google::protobuf::int32 chairid() const;
  inline void set_chairid(::google::protobuf::int32 value);

  // optional bool forceLeave = 4;
  inline bool has_forceleave() const;
  inline void clear_forceleave();
  static const int kForceLeaveFieldNumber = 4;
  inline bool forceleave() const;
  inline void set_forceleave(bool value);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserStandUp)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_chairid();
  inline void clear_has_chairid();
  inline void set_has_forceleave();
  inline void clear_has_forceleave();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 tableid_;
  ::google::protobuf::int32 chairid_;
  bool forceleave_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserStandUp* default_instance_;
};
// -------------------------------------------------------------------

class GSUserChangeTable : public ::google::protobuf::MessageLite {
 public:
  GSUserChangeTable();
  virtual ~GSUserChangeTable();

  GSUserChangeTable(const GSUserChangeTable& from);

  inline GSUserChangeTable& operator=(const GSUserChangeTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserChangeTable& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserChangeTable* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserChangeTable* other);

  // implements Message ----------------------------------------------

  GSUserChangeTable* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserChangeTable& from);
  void MergeFrom(const GSUserChangeTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserChangeTable)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserChangeTable* default_instance_;
};
// -------------------------------------------------------------------

class GSUserRequestFailure : public ::google::protobuf::MessageLite {
 public:
  GSUserRequestFailure();
  virtual ~GSUserRequestFailure();

  GSUserRequestFailure(const GSUserRequestFailure& from);

  inline GSUserRequestFailure& operator=(const GSUserRequestFailure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserRequestFailure& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserRequestFailure* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserRequestFailure* other);

  // implements Message ----------------------------------------------

  GSUserRequestFailure* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserRequestFailure& from);
  void MergeFrom(const GSUserRequestFailure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 errorCode = 1;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 errorcode() const;
  inline void set_errorcode(::google::protobuf::int32 value);

  // optional string describeString = 2;
  inline bool has_describestring() const;
  inline void clear_describestring();
  static const int kDescribeStringFieldNumber = 2;
  inline const ::std::string& describestring() const;
  inline void set_describestring(const ::std::string& value);
  inline void set_describestring(const char* value);
  inline void set_describestring(const char* value, size_t size);
  inline ::std::string* mutable_describestring();
  inline ::std::string* release_describestring();
  inline void set_allocated_describestring(::std::string* describestring);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserRequestFailure)
 private:
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_describestring();
  inline void clear_has_describestring();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* describestring_;
  ::google::protobuf::int32 errorcode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserRequestFailure* default_instance_;
};
// -------------------------------------------------------------------

class GSUserEnter : public ::google::protobuf::MessageLite {
 public:
  GSUserEnter();
  virtual ~GSUserEnter();

  GSUserEnter(const GSUserEnter& from);

  inline GSUserEnter& operator=(const GSUserEnter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserEnter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserEnter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserEnter* other);

  // implements Message ----------------------------------------------

  GSUserEnter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserEnter& from);
  void MergeFrom(const GSUserEnter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional int32 faceID = 2;
  inline bool has_faceid() const;
  inline void clear_faceid();
  static const int kFaceIDFieldNumber = 2;
  inline ::google::protobuf::int32 faceid() const;
  inline void set_faceid(::google::protobuf::int32 value);

  // optional int32 gender = 3;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 3;
  inline ::google::protobuf::int32 gender() const;
  inline void set_gender(::google::protobuf::int32 value);

  // required .GameServer.tagUserStatus userStatus = 4;
  inline bool has_userstatus() const;
  inline void clear_userstatus();
  static const int kUserStatusFieldNumber = 4;
  inline const ::GameServer::tagUserStatus& userstatus() const;
  inline ::GameServer::tagUserStatus* mutable_userstatus();
  inline ::GameServer::tagUserStatus* release_userstatus();
  inline void set_allocated_userstatus(::GameServer::tagUserStatus* userstatus);

  // required int64 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::int64 score() const;
  inline void set_score(::google::protobuf::int64 value);

  // optional string nickName = 6;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 6;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserEnter)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_faceid();
  inline void clear_has_faceid();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_userstatus();
  inline void clear_has_userstatus();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 faceid_;
  ::GameServer::tagUserStatus* userstatus_;
  ::google::protobuf::int64 score_;
  ::std::string* nickname_;
  ::google::protobuf::int32 gender_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserEnter* default_instance_;
};
// -------------------------------------------------------------------

class GSUserLeave : public ::google::protobuf::MessageLite {
 public:
  GSUserLeave();
  virtual ~GSUserLeave();

  GSUserLeave(const GSUserLeave& from);

  inline GSUserLeave& operator=(const GSUserLeave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserLeave& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserLeave* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserLeave* other);

  // implements Message ----------------------------------------------

  GSUserLeave* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserLeave& from);
  void MergeFrom(const GSUserLeave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserLeave)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserLeave* default_instance_;
};
// -------------------------------------------------------------------

class GSUserStatus : public ::google::protobuf::MessageLite {
 public:
  GSUserStatus();
  virtual ~GSUserStatus();

  GSUserStatus(const GSUserStatus& from);

  inline GSUserStatus& operator=(const GSUserStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserStatus* other);

  // implements Message ----------------------------------------------

  GSUserStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserStatus& from);
  void MergeFrom(const GSUserStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required .GameServer.tagUserStatus userStatus = 2;
  inline bool has_userstatus() const;
  inline void clear_userstatus();
  static const int kUserStatusFieldNumber = 2;
  inline const ::GameServer::tagUserStatus& userstatus() const;
  inline ::GameServer::tagUserStatus* mutable_userstatus();
  inline ::GameServer::tagUserStatus* release_userstatus();
  inline void set_allocated_userstatus(::GameServer::tagUserStatus* userstatus);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserStatus)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_userstatus();
  inline void clear_has_userstatus();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::GameServer::tagUserStatus* userstatus_;
  ::google::protobuf::int32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserStatus* default_instance_;
};
// -------------------------------------------------------------------

class GSUserScore : public ::google::protobuf::MessageLite {
 public:
  GSUserScore();
  virtual ~GSUserScore();

  GSUserScore(const GSUserScore& from);

  inline GSUserScore& operator=(const GSUserScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserScore& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserScore* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserScore* other);

  // implements Message ----------------------------------------------

  GSUserScore* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserScore& from);
  void MergeFrom(const GSUserScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required .GameServer.tagUserScore userScore = 2;
  inline bool has_userscore() const;
  inline void clear_userscore();
  static const int kUserScoreFieldNumber = 2;
  inline const ::GameServer::tagUserScore& userscore() const;
  inline ::GameServer::tagUserScore* mutable_userscore();
  inline ::GameServer::tagUserScore* release_userscore();
  inline void set_allocated_userscore(::GameServer::tagUserScore* userscore);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserScore)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_userscore();
  inline void clear_has_userscore();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::GameServer::tagUserScore* userscore_;
  ::google::protobuf::int32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserScore* default_instance_;
};
// -------------------------------------------------------------------

class GSGameOption : public ::google::protobuf::MessageLite {
 public:
  GSGameOption();
  virtual ~GSGameOption();

  GSGameOption(const GSGameOption& from);

  inline GSGameOption& operator=(const GSGameOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSGameOption& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSGameOption* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSGameOption* other);

  // implements Message ----------------------------------------------

  GSGameOption* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSGameOption& from);
  void MergeFrom(const GSGameOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // optional bool allowLookon = 2;
  inline bool has_allowlookon() const;
  inline void clear_allowlookon();
  static const int kAllowLookonFieldNumber = 2;
  inline bool allowlookon() const;
  inline void set_allowlookon(bool value);

  // @@protoc_insertion_point(class_scope:GameServer.GSGameOption)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_allowlookon();
  inline void clear_has_allowlookon();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  bool allowlookon_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSGameOption* default_instance_;
};
// -------------------------------------------------------------------

class GSUserReady : public ::google::protobuf::MessageLite {
 public:
  GSUserReady();
  virtual ~GSUserReady();

  GSUserReady(const GSUserReady& from);

  inline GSUserReady& operator=(const GSUserReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserReady& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserReady* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserReady* other);

  // implements Message ----------------------------------------------

  GSUserReady* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserReady& from);
  void MergeFrom(const GSUserReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserReady)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserReady* default_instance_;
};
// -------------------------------------------------------------------

class Proto_GameStatus : public ::google::protobuf::MessageLite {
 public:
  Proto_GameStatus();
  virtual ~Proto_GameStatus();

  Proto_GameStatus(const Proto_GameStatus& from);

  inline Proto_GameStatus& operator=(const Proto_GameStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Proto_GameStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Proto_GameStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Proto_GameStatus* other);

  // implements Message ----------------------------------------------

  Proto_GameStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Proto_GameStatus& from);
  void MergeFrom(const Proto_GameStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cbGameStatus = 1;
  inline bool has_cbgamestatus() const;
  inline void clear_cbgamestatus();
  static const int kCbGameStatusFieldNumber = 1;
  inline ::google::protobuf::int32 cbgamestatus() const;
  inline void set_cbgamestatus(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServer.Proto_GameStatus)
 private:
  inline void set_has_cbgamestatus();
  inline void clear_has_cbgamestatus();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 cbgamestatus_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static Proto_GameStatus* default_instance_;
};
// -------------------------------------------------------------------

class SQL_S_Scroll_Message : public ::google::protobuf::MessageLite {
 public:
  SQL_S_Scroll_Message();
  virtual ~SQL_S_Scroll_Message();

  SQL_S_Scroll_Message(const SQL_S_Scroll_Message& from);

  inline SQL_S_Scroll_Message& operator=(const SQL_S_Scroll_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SQL_S_Scroll_Message& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SQL_S_Scroll_Message* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SQL_S_Scroll_Message* other);

  // implements Message ----------------------------------------------

  SQL_S_Scroll_Message* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SQL_S_Scroll_Message& from);
  void MergeFrom(const SQL_S_Scroll_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 bMessageType = 1;
  inline bool has_bmessagetype() const;
  inline void clear_bmessagetype();
  static const int kBMessageTypeFieldNumber = 1;
  inline ::google::protobuf::int32 bmessagetype() const;
  inline void set_bmessagetype(::google::protobuf::int32 value);

  // repeated string sScrollMsg = 2;
  inline int sscrollmsg_size() const;
  inline void clear_sscrollmsg();
  static const int kSScrollMsgFieldNumber = 2;
  inline const ::std::string& sscrollmsg(int index) const;
  inline ::std::string* mutable_sscrollmsg(int index);
  inline void set_sscrollmsg(int index, const ::std::string& value);
  inline void set_sscrollmsg(int index, const char* value);
  inline void set_sscrollmsg(int index, const char* value, size_t size);
  inline ::std::string* add_sscrollmsg();
  inline void add_sscrollmsg(const ::std::string& value);
  inline void add_sscrollmsg(const char* value);
  inline void add_sscrollmsg(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sscrollmsg() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sscrollmsg();

  // @@protoc_insertion_point(class_scope:GameServer.SQL_S_Scroll_Message)
 private:
  inline void set_has_bmessagetype();
  inline void clear_has_bmessagetype();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sscrollmsg_;
  ::google::protobuf::int32 bmessagetype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static SQL_S_Scroll_Message* default_instance_;
};
// -------------------------------------------------------------------

class GSSystemMessage : public ::google::protobuf::MessageLite {
 public:
  GSSystemMessage();
  virtual ~GSSystemMessage();

  GSSystemMessage(const GSSystemMessage& from);

  inline GSSystemMessage& operator=(const GSSystemMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSSystemMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSSystemMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSSystemMessage* other);

  // implements Message ----------------------------------------------

  GSSystemMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSSystemMessage& from);
  void MergeFrom(const GSSystemMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::google::protobuf::int32 messagetype() const;
  inline void set_messagetype(::google::protobuf::int32 value);

  // required string messageString = 2;
  inline bool has_messagestring() const;
  inline void clear_messagestring();
  static const int kMessageStringFieldNumber = 2;
  inline const ::std::string& messagestring() const;
  inline void set_messagestring(const ::std::string& value);
  inline void set_messagestring(const char* value);
  inline void set_messagestring(const char* value, size_t size);
  inline ::std::string* mutable_messagestring();
  inline ::std::string* release_messagestring();
  inline void set_allocated_messagestring(::std::string* messagestring);

  // @@protoc_insertion_point(class_scope:GameServer.GSSystemMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_messagestring();
  inline void clear_has_messagestring();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* messagestring_;
  ::google::protobuf::int32 messagetype_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSSystemMessage* default_instance_;
};
// -------------------------------------------------------------------

class GSUserHeart : public ::google::protobuf::MessageLite {
 public:
  GSUserHeart();
  virtual ~GSUserHeart();

  GSUserHeart(const GSUserHeart& from);

  inline GSUserHeart& operator=(const GSUserHeart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GSUserHeart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GSUserHeart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GSUserHeart* other);

  // implements Message ----------------------------------------------

  GSUserHeart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GSUserHeart& from);
  void MergeFrom(const GSUserHeart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userID = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 1;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameServer.GSUserHeart)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_GameServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_GameServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_GameServer_2eproto();
  friend void protobuf_ShutdownFile_GameServer_2eproto();

  void InitAsDefaultInstance();
  static GSUserHeart* default_instance_;
};
// ===================================================================


// ===================================================================

// tagUserStatus

// required int32 tableID = 1;
inline bool tagUserStatus::has_tableid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagUserStatus::set_has_tableid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagUserStatus::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagUserStatus::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 tagUserStatus::tableid() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserStatus.tableID)
  return tableid_;
}
inline void tagUserStatus::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserStatus.tableID)
}

// required int32 chairID = 2;
inline bool tagUserStatus::has_chairid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagUserStatus::set_has_chairid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagUserStatus::clear_has_chairid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagUserStatus::clear_chairid() {
  chairid_ = 0;
  clear_has_chairid();
}
inline ::google::protobuf::int32 tagUserStatus::chairid() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserStatus.chairID)
  return chairid_;
}
inline void tagUserStatus::set_chairid(::google::protobuf::int32 value) {
  set_has_chairid();
  chairid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserStatus.chairID)
}

// required .GameServer.enumUserStatus userStatus = 3;
inline bool tagUserStatus::has_userstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tagUserStatus::set_has_userstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tagUserStatus::clear_has_userstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tagUserStatus::clear_userstatus() {
  userstatus_ = 0;
  clear_has_userstatus();
}
inline ::GameServer::enumUserStatus tagUserStatus::userstatus() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserStatus.userStatus)
  return static_cast< ::GameServer::enumUserStatus >(userstatus_);
}
inline void tagUserStatus::set_userstatus(::GameServer::enumUserStatus value) {
  assert(::GameServer::enumUserStatus_IsValid(value));
  set_has_userstatus();
  userstatus_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserStatus.userStatus)
}

// -------------------------------------------------------------------

// tagUserScore

// required int64 userScore = 1;
inline bool tagUserScore::has_userscore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagUserScore::set_has_userscore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagUserScore::clear_has_userscore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagUserScore::clear_userscore() {
  userscore_ = GOOGLE_LONGLONG(0);
  clear_has_userscore();
}
inline ::google::protobuf::int64 tagUserScore::userscore() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserScore.userScore)
  return userscore_;
}
inline void tagUserScore::set_userscore(::google::protobuf::int64 value) {
  set_has_userscore();
  userscore_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserScore.userScore)
}

// optional int32 winCount = 2;
inline bool tagUserScore::has_wincount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagUserScore::set_has_wincount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagUserScore::clear_has_wincount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagUserScore::clear_wincount() {
  wincount_ = 0;
  clear_has_wincount();
}
inline ::google::protobuf::int32 tagUserScore::wincount() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserScore.winCount)
  return wincount_;
}
inline void tagUserScore::set_wincount(::google::protobuf::int32 value) {
  set_has_wincount();
  wincount_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserScore.winCount)
}

// optional int32 lostCount = 3;
inline bool tagUserScore::has_lostcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tagUserScore::set_has_lostcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tagUserScore::clear_has_lostcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tagUserScore::clear_lostcount() {
  lostcount_ = 0;
  clear_has_lostcount();
}
inline ::google::protobuf::int32 tagUserScore::lostcount() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserScore.lostCount)
  return lostcount_;
}
inline void tagUserScore::set_lostcount(::google::protobuf::int32 value) {
  set_has_lostcount();
  lostcount_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserScore.lostCount)
}

// optional int32 drawCount = 4;
inline bool tagUserScore::has_drawcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tagUserScore::set_has_drawcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tagUserScore::clear_has_drawcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tagUserScore::clear_drawcount() {
  drawcount_ = 0;
  clear_has_drawcount();
}
inline ::google::protobuf::int32 tagUserScore::drawcount() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserScore.drawCount)
  return drawcount_;
}
inline void tagUserScore::set_drawcount(::google::protobuf::int32 value) {
  set_has_drawcount();
  drawcount_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserScore.drawCount)
}

// optional int32 fleeCount = 5;
inline bool tagUserScore::has_fleecount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tagUserScore::set_has_fleecount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tagUserScore::clear_has_fleecount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tagUserScore::clear_fleecount() {
  fleecount_ = 0;
  clear_has_fleecount();
}
inline ::google::protobuf::int32 tagUserScore::fleecount() const {
  // @@protoc_insertion_point(field_get:GameServer.tagUserScore.fleeCount)
  return fleecount_;
}
inline void tagUserScore::set_fleecount(::google::protobuf::int32 value) {
  set_has_fleecount();
  fleecount_ = value;
  // @@protoc_insertion_point(field_set:GameServer.tagUserScore.fleeCount)
}

// -------------------------------------------------------------------

// GSLogonTokenID

// required int32 merchantID = 1;
inline bool GSLogonTokenID::has_merchantid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSLogonTokenID::set_has_merchantid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSLogonTokenID::clear_has_merchantid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSLogonTokenID::clear_merchantid() {
  merchantid_ = 0;
  clear_has_merchantid();
}
inline ::google::protobuf::int32 GSLogonTokenID::merchantid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonTokenID.merchantID)
  return merchantid_;
}
inline void GSLogonTokenID::set_merchantid(::google::protobuf::int32 value) {
  set_has_merchantid();
  merchantid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSLogonTokenID.merchantID)
}

// required int32 userID = 2;
inline bool GSLogonTokenID::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSLogonTokenID::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSLogonTokenID::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSLogonTokenID::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSLogonTokenID::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonTokenID.userID)
  return userid_;
}
inline void GSLogonTokenID::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSLogonTokenID.userID)
}

// required string tokenID = 3;
inline bool GSLogonTokenID::has_tokenid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GSLogonTokenID::set_has_tokenid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GSLogonTokenID::clear_has_tokenid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GSLogonTokenID::clear_tokenid() {
  if (tokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tokenid_->clear();
  }
  clear_has_tokenid();
}
inline const ::std::string& GSLogonTokenID::tokenid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonTokenID.tokenID)
  return *tokenid_;
}
inline void GSLogonTokenID::set_tokenid(const ::std::string& value) {
  set_has_tokenid();
  if (tokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tokenid_ = new ::std::string;
  }
  tokenid_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSLogonTokenID.tokenID)
}
inline void GSLogonTokenID::set_tokenid(const char* value) {
  set_has_tokenid();
  if (tokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tokenid_ = new ::std::string;
  }
  tokenid_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSLogonTokenID.tokenID)
}
inline void GSLogonTokenID::set_tokenid(const char* value, size_t size) {
  set_has_tokenid();
  if (tokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tokenid_ = new ::std::string;
  }
  tokenid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSLogonTokenID.tokenID)
}
inline ::std::string* GSLogonTokenID::mutable_tokenid() {
  set_has_tokenid();
  if (tokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tokenid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSLogonTokenID.tokenID)
  return tokenid_;
}
inline ::std::string* GSLogonTokenID::release_tokenid() {
  clear_has_tokenid();
  if (tokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tokenid_;
    tokenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSLogonTokenID::set_allocated_tokenid(::std::string* tokenid) {
  if (tokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tokenid_;
  }
  if (tokenid) {
    set_has_tokenid();
    tokenid_ = tokenid;
  } else {
    clear_has_tokenid();
    tokenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSLogonTokenID.tokenID)
}

// required string machineID = 4;
inline bool GSLogonTokenID::has_machineid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GSLogonTokenID::set_has_machineid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GSLogonTokenID::clear_has_machineid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GSLogonTokenID::clear_machineid() {
  if (machineid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machineid_->clear();
  }
  clear_has_machineid();
}
inline const ::std::string& GSLogonTokenID::machineid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonTokenID.machineID)
  return *machineid_;
}
inline void GSLogonTokenID::set_machineid(const ::std::string& value) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSLogonTokenID.machineID)
}
inline void GSLogonTokenID::set_machineid(const char* value) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSLogonTokenID.machineID)
}
inline void GSLogonTokenID::set_machineid(const char* value, size_t size) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSLogonTokenID.machineID)
}
inline ::std::string* GSLogonTokenID::mutable_machineid() {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machineid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSLogonTokenID.machineID)
  return machineid_;
}
inline ::std::string* GSLogonTokenID::release_machineid() {
  clear_has_machineid();
  if (machineid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = machineid_;
    machineid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSLogonTokenID::set_allocated_machineid(::std::string* machineid) {
  if (machineid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete machineid_;
  }
  if (machineid) {
    set_has_machineid();
    machineid_ = machineid;
  } else {
    clear_has_machineid();
    machineid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSLogonTokenID.machineID)
}

// optional string clientIP = 5;
inline bool GSLogonTokenID::has_clientip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GSLogonTokenID::set_has_clientip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GSLogonTokenID::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GSLogonTokenID::clear_clientip() {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_->clear();
  }
  clear_has_clientip();
}
inline const ::std::string& GSLogonTokenID::clientip() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonTokenID.clientIP)
  return *clientip_;
}
inline void GSLogonTokenID::set_clientip(const ::std::string& value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSLogonTokenID.clientIP)
}
inline void GSLogonTokenID::set_clientip(const char* value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSLogonTokenID.clientIP)
}
inline void GSLogonTokenID::set_clientip(const char* value, size_t size) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSLogonTokenID.clientIP)
}
inline ::std::string* GSLogonTokenID::mutable_clientip() {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSLogonTokenID.clientIP)
  return clientip_;
}
inline ::std::string* GSLogonTokenID::release_clientip() {
  clear_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientip_;
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSLogonTokenID::set_allocated_clientip(::std::string* clientip) {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientip_;
  }
  if (clientip) {
    set_has_clientip();
    clientip_ = clientip;
  } else {
    clear_has_clientip();
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSLogonTokenID.clientIP)
}

// required int32 deviceType = 6;
inline bool GSLogonTokenID::has_devicetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GSLogonTokenID::set_has_devicetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GSLogonTokenID::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GSLogonTokenID::clear_devicetype() {
  devicetype_ = 0;
  clear_has_devicetype();
}
inline ::google::protobuf::int32 GSLogonTokenID::devicetype() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonTokenID.deviceType)
  return devicetype_;
}
inline void GSLogonTokenID::set_devicetype(::google::protobuf::int32 value) {
  set_has_devicetype();
  devicetype_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSLogonTokenID.deviceType)
}

// -------------------------------------------------------------------

// GSLogonSuccess

// optional int64 userRight = 1;
inline bool GSLogonSuccess::has_userright() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSLogonSuccess::set_has_userright() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSLogonSuccess::clear_has_userright() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSLogonSuccess::clear_userright() {
  userright_ = GOOGLE_LONGLONG(0);
  clear_has_userright();
}
inline ::google::protobuf::int64 GSLogonSuccess::userright() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonSuccess.userRight)
  return userright_;
}
inline void GSLogonSuccess::set_userright(::google::protobuf::int64 value) {
  set_has_userright();
  userright_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSLogonSuccess.userRight)
}

// optional int64 masterRight = 2;
inline bool GSLogonSuccess::has_masterright() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSLogonSuccess::set_has_masterright() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSLogonSuccess::clear_has_masterright() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSLogonSuccess::clear_masterright() {
  masterright_ = GOOGLE_LONGLONG(0);
  clear_has_masterright();
}
inline ::google::protobuf::int64 GSLogonSuccess::masterright() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonSuccess.masterRight)
  return masterright_;
}
inline void GSLogonSuccess::set_masterright(::google::protobuf::int64 value) {
  set_has_masterright();
  masterright_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSLogonSuccess.masterRight)
}

// -------------------------------------------------------------------

// GSLogonFinish

// optional int32 resultCode = 1;
inline bool GSLogonFinish::has_resultcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSLogonFinish::set_has_resultcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSLogonFinish::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSLogonFinish::clear_resultcode() {
  resultcode_ = 0;
  clear_has_resultcode();
}
inline ::google::protobuf::int32 GSLogonFinish::resultcode() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonFinish.resultCode)
  return resultcode_;
}
inline void GSLogonFinish::set_resultcode(::google::protobuf::int32 value) {
  set_has_resultcode();
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSLogonFinish.resultCode)
}

// optional string resultStr = 2;
inline bool GSLogonFinish::has_resultstr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSLogonFinish::set_has_resultstr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSLogonFinish::clear_has_resultstr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSLogonFinish::clear_resultstr() {
  if (resultstr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultstr_->clear();
  }
  clear_has_resultstr();
}
inline const ::std::string& GSLogonFinish::resultstr() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonFinish.resultStr)
  return *resultstr_;
}
inline void GSLogonFinish::set_resultstr(const ::std::string& value) {
  set_has_resultstr();
  if (resultstr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultstr_ = new ::std::string;
  }
  resultstr_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSLogonFinish.resultStr)
}
inline void GSLogonFinish::set_resultstr(const char* value) {
  set_has_resultstr();
  if (resultstr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultstr_ = new ::std::string;
  }
  resultstr_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSLogonFinish.resultStr)
}
inline void GSLogonFinish::set_resultstr(const char* value, size_t size) {
  set_has_resultstr();
  if (resultstr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultstr_ = new ::std::string;
  }
  resultstr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSLogonFinish.resultStr)
}
inline ::std::string* GSLogonFinish::mutable_resultstr() {
  set_has_resultstr();
  if (resultstr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resultstr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSLogonFinish.resultStr)
  return resultstr_;
}
inline ::std::string* GSLogonFinish::release_resultstr() {
  clear_has_resultstr();
  if (resultstr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resultstr_;
    resultstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSLogonFinish::set_allocated_resultstr(::std::string* resultstr) {
  if (resultstr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resultstr_;
  }
  if (resultstr) {
    set_has_resultstr();
    resultstr_ = resultstr;
  } else {
    clear_has_resultstr();
    resultstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSLogonFinish.resultStr)
}

// -------------------------------------------------------------------

// GSLogonFailure

// optional int32 errorCode = 1;
inline bool GSLogonFailure::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSLogonFailure::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSLogonFailure::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSLogonFailure::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 GSLogonFailure::errorcode() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonFailure.errorCode)
  return errorcode_;
}
inline void GSLogonFailure::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSLogonFailure.errorCode)
}

// optional string describeString = 2;
inline bool GSLogonFailure::has_describestring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSLogonFailure::set_has_describestring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSLogonFailure::clear_has_describestring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSLogonFailure::clear_describestring() {
  if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_->clear();
  }
  clear_has_describestring();
}
inline const ::std::string& GSLogonFailure::describestring() const {
  // @@protoc_insertion_point(field_get:GameServer.GSLogonFailure.describeString)
  return *describestring_;
}
inline void GSLogonFailure::set_describestring(const ::std::string& value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSLogonFailure.describeString)
}
inline void GSLogonFailure::set_describestring(const char* value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSLogonFailure.describeString)
}
inline void GSLogonFailure::set_describestring(const char* value, size_t size) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSLogonFailure.describeString)
}
inline ::std::string* GSLogonFailure::mutable_describestring() {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSLogonFailure.describeString)
  return describestring_;
}
inline ::std::string* GSLogonFailure::release_describestring() {
  clear_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = describestring_;
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSLogonFailure::set_allocated_describestring(::std::string* describestring) {
  if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete describestring_;
  }
  if (describestring) {
    set_has_describestring();
    describestring_ = describestring;
  } else {
    clear_has_describestring();
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSLogonFailure.describeString)
}

// -------------------------------------------------------------------

// GSUserSitDown

// required int32 userID = 1;
inline bool GSUserSitDown::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserSitDown::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserSitDown::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserSitDown::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserSitDown::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserSitDown.userID)
  return userid_;
}
inline void GSUserSitDown::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserSitDown.userID)
}

// required int32 tableID = 2;
inline bool GSUserSitDown::has_tableid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSUserSitDown::set_has_tableid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSUserSitDown::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSUserSitDown::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 GSUserSitDown::tableid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserSitDown.tableID)
  return tableid_;
}
inline void GSUserSitDown::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserSitDown.tableID)
}

// required int32 chairID = 3;
inline bool GSUserSitDown::has_chairid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GSUserSitDown::set_has_chairid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GSUserSitDown::clear_has_chairid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GSUserSitDown::clear_chairid() {
  chairid_ = 0;
  clear_has_chairid();
}
inline ::google::protobuf::int32 GSUserSitDown::chairid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserSitDown.chairID)
  return chairid_;
}
inline void GSUserSitDown::set_chairid(::google::protobuf::int32 value) {
  set_has_chairid();
  chairid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserSitDown.chairID)
}

// optional string tableTokenID = 4;
inline bool GSUserSitDown::has_tabletokenid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GSUserSitDown::set_has_tabletokenid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GSUserSitDown::clear_has_tabletokenid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GSUserSitDown::clear_tabletokenid() {
  if (tabletokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tabletokenid_->clear();
  }
  clear_has_tabletokenid();
}
inline const ::std::string& GSUserSitDown::tabletokenid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserSitDown.tableTokenID)
  return *tabletokenid_;
}
inline void GSUserSitDown::set_tabletokenid(const ::std::string& value) {
  set_has_tabletokenid();
  if (tabletokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tabletokenid_ = new ::std::string;
  }
  tabletokenid_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSUserSitDown.tableTokenID)
}
inline void GSUserSitDown::set_tabletokenid(const char* value) {
  set_has_tabletokenid();
  if (tabletokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tabletokenid_ = new ::std::string;
  }
  tabletokenid_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSUserSitDown.tableTokenID)
}
inline void GSUserSitDown::set_tabletokenid(const char* value, size_t size) {
  set_has_tabletokenid();
  if (tabletokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tabletokenid_ = new ::std::string;
  }
  tabletokenid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSUserSitDown.tableTokenID)
}
inline ::std::string* GSUserSitDown::mutable_tabletokenid() {
  set_has_tabletokenid();
  if (tabletokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tabletokenid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSUserSitDown.tableTokenID)
  return tabletokenid_;
}
inline ::std::string* GSUserSitDown::release_tabletokenid() {
  clear_has_tabletokenid();
  if (tabletokenid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tabletokenid_;
    tabletokenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSUserSitDown::set_allocated_tabletokenid(::std::string* tabletokenid) {
  if (tabletokenid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tabletokenid_;
  }
  if (tabletokenid) {
    set_has_tabletokenid();
    tabletokenid_ = tabletokenid;
  } else {
    clear_has_tabletokenid();
    tabletokenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSUserSitDown.tableTokenID)
}

// -------------------------------------------------------------------

// GSUserStandUp

// required int32 userID = 1;
inline bool GSUserStandUp::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserStandUp::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserStandUp::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserStandUp::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserStandUp::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserStandUp.userID)
  return userid_;
}
inline void GSUserStandUp::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserStandUp.userID)
}

// required int32 tableID = 2;
inline bool GSUserStandUp::has_tableid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSUserStandUp::set_has_tableid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSUserStandUp::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSUserStandUp::clear_tableid() {
  tableid_ = 0;
  clear_has_tableid();
}
inline ::google::protobuf::int32 GSUserStandUp::tableid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserStandUp.tableID)
  return tableid_;
}
inline void GSUserStandUp::set_tableid(::google::protobuf::int32 value) {
  set_has_tableid();
  tableid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserStandUp.tableID)
}

// required int32 chairID = 3;
inline bool GSUserStandUp::has_chairid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GSUserStandUp::set_has_chairid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GSUserStandUp::clear_has_chairid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GSUserStandUp::clear_chairid() {
  chairid_ = 0;
  clear_has_chairid();
}
inline ::google::protobuf::int32 GSUserStandUp::chairid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserStandUp.chairID)
  return chairid_;
}
inline void GSUserStandUp::set_chairid(::google::protobuf::int32 value) {
  set_has_chairid();
  chairid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserStandUp.chairID)
}

// optional bool forceLeave = 4;
inline bool GSUserStandUp::has_forceleave() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GSUserStandUp::set_has_forceleave() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GSUserStandUp::clear_has_forceleave() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GSUserStandUp::clear_forceleave() {
  forceleave_ = false;
  clear_has_forceleave();
}
inline bool GSUserStandUp::forceleave() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserStandUp.forceLeave)
  return forceleave_;
}
inline void GSUserStandUp::set_forceleave(bool value) {
  set_has_forceleave();
  forceleave_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserStandUp.forceLeave)
}

// -------------------------------------------------------------------

// GSUserChangeTable

// required int32 userID = 1;
inline bool GSUserChangeTable::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserChangeTable::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserChangeTable::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserChangeTable::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserChangeTable::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserChangeTable.userID)
  return userid_;
}
inline void GSUserChangeTable::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserChangeTable.userID)
}

// -------------------------------------------------------------------

// GSUserRequestFailure

// optional int32 errorCode = 1;
inline bool GSUserRequestFailure::has_errorcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserRequestFailure::set_has_errorcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserRequestFailure::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserRequestFailure::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 GSUserRequestFailure::errorcode() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserRequestFailure.errorCode)
  return errorcode_;
}
inline void GSUserRequestFailure::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserRequestFailure.errorCode)
}

// optional string describeString = 2;
inline bool GSUserRequestFailure::has_describestring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSUserRequestFailure::set_has_describestring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSUserRequestFailure::clear_has_describestring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSUserRequestFailure::clear_describestring() {
  if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_->clear();
  }
  clear_has_describestring();
}
inline const ::std::string& GSUserRequestFailure::describestring() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserRequestFailure.describeString)
  return *describestring_;
}
inline void GSUserRequestFailure::set_describestring(const ::std::string& value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSUserRequestFailure.describeString)
}
inline void GSUserRequestFailure::set_describestring(const char* value) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSUserRequestFailure.describeString)
}
inline void GSUserRequestFailure::set_describestring(const char* value, size_t size) {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  describestring_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSUserRequestFailure.describeString)
}
inline ::std::string* GSUserRequestFailure::mutable_describestring() {
  set_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    describestring_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSUserRequestFailure.describeString)
  return describestring_;
}
inline ::std::string* GSUserRequestFailure::release_describestring() {
  clear_has_describestring();
  if (describestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = describestring_;
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSUserRequestFailure::set_allocated_describestring(::std::string* describestring) {
  if (describestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete describestring_;
  }
  if (describestring) {
    set_has_describestring();
    describestring_ = describestring;
  } else {
    clear_has_describestring();
    describestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSUserRequestFailure.describeString)
}

// -------------------------------------------------------------------

// GSUserEnter

// required int32 userID = 1;
inline bool GSUserEnter::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserEnter::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserEnter::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserEnter::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserEnter::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserEnter.userID)
  return userid_;
}
inline void GSUserEnter::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserEnter.userID)
}

// optional int32 faceID = 2;
inline bool GSUserEnter::has_faceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSUserEnter::set_has_faceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSUserEnter::clear_has_faceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSUserEnter::clear_faceid() {
  faceid_ = 0;
  clear_has_faceid();
}
inline ::google::protobuf::int32 GSUserEnter::faceid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserEnter.faceID)
  return faceid_;
}
inline void GSUserEnter::set_faceid(::google::protobuf::int32 value) {
  set_has_faceid();
  faceid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserEnter.faceID)
}

// optional int32 gender = 3;
inline bool GSUserEnter::has_gender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GSUserEnter::set_has_gender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GSUserEnter::clear_has_gender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GSUserEnter::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::google::protobuf::int32 GSUserEnter::gender() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserEnter.gender)
  return gender_;
}
inline void GSUserEnter::set_gender(::google::protobuf::int32 value) {
  set_has_gender();
  gender_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserEnter.gender)
}

// required .GameServer.tagUserStatus userStatus = 4;
inline bool GSUserEnter::has_userstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GSUserEnter::set_has_userstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GSUserEnter::clear_has_userstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GSUserEnter::clear_userstatus() {
  if (userstatus_ != NULL) userstatus_->::GameServer::tagUserStatus::Clear();
  clear_has_userstatus();
}
inline const ::GameServer::tagUserStatus& GSUserEnter::userstatus() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserEnter.userStatus)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userstatus_ != NULL ? *userstatus_ : *default_instance().userstatus_;
#else
  return userstatus_ != NULL ? *userstatus_ : *default_instance_->userstatus_;
#endif
}
inline ::GameServer::tagUserStatus* GSUserEnter::mutable_userstatus() {
  set_has_userstatus();
  if (userstatus_ == NULL) userstatus_ = new ::GameServer::tagUserStatus;
  // @@protoc_insertion_point(field_mutable:GameServer.GSUserEnter.userStatus)
  return userstatus_;
}
inline ::GameServer::tagUserStatus* GSUserEnter::release_userstatus() {
  clear_has_userstatus();
  ::GameServer::tagUserStatus* temp = userstatus_;
  userstatus_ = NULL;
  return temp;
}
inline void GSUserEnter::set_allocated_userstatus(::GameServer::tagUserStatus* userstatus) {
  delete userstatus_;
  userstatus_ = userstatus;
  if (userstatus) {
    set_has_userstatus();
  } else {
    clear_has_userstatus();
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSUserEnter.userStatus)
}

// required int64 score = 5;
inline bool GSUserEnter::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GSUserEnter::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GSUserEnter::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GSUserEnter::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
  clear_has_score();
}
inline ::google::protobuf::int64 GSUserEnter::score() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserEnter.score)
  return score_;
}
inline void GSUserEnter::set_score(::google::protobuf::int64 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserEnter.score)
}

// optional string nickName = 6;
inline bool GSUserEnter::has_nickname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GSUserEnter::set_has_nickname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GSUserEnter::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GSUserEnter::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& GSUserEnter::nickname() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserEnter.nickName)
  return *nickname_;
}
inline void GSUserEnter::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSUserEnter.nickName)
}
inline void GSUserEnter::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSUserEnter.nickName)
}
inline void GSUserEnter::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSUserEnter.nickName)
}
inline ::std::string* GSUserEnter::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSUserEnter.nickName)
  return nickname_;
}
inline ::std::string* GSUserEnter::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSUserEnter::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSUserEnter.nickName)
}

// -------------------------------------------------------------------

// GSUserLeave

// optional int32 userID = 1;
inline bool GSUserLeave::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserLeave::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserLeave::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserLeave::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserLeave::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserLeave.userID)
  return userid_;
}
inline void GSUserLeave::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserLeave.userID)
}

// -------------------------------------------------------------------

// GSUserStatus

// required int32 userID = 1;
inline bool GSUserStatus::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserStatus::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserStatus::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserStatus::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserStatus::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserStatus.userID)
  return userid_;
}
inline void GSUserStatus::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserStatus.userID)
}

// required .GameServer.tagUserStatus userStatus = 2;
inline bool GSUserStatus::has_userstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSUserStatus::set_has_userstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSUserStatus::clear_has_userstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSUserStatus::clear_userstatus() {
  if (userstatus_ != NULL) userstatus_->::GameServer::tagUserStatus::Clear();
  clear_has_userstatus();
}
inline const ::GameServer::tagUserStatus& GSUserStatus::userstatus() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserStatus.userStatus)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userstatus_ != NULL ? *userstatus_ : *default_instance().userstatus_;
#else
  return userstatus_ != NULL ? *userstatus_ : *default_instance_->userstatus_;
#endif
}
inline ::GameServer::tagUserStatus* GSUserStatus::mutable_userstatus() {
  set_has_userstatus();
  if (userstatus_ == NULL) userstatus_ = new ::GameServer::tagUserStatus;
  // @@protoc_insertion_point(field_mutable:GameServer.GSUserStatus.userStatus)
  return userstatus_;
}
inline ::GameServer::tagUserStatus* GSUserStatus::release_userstatus() {
  clear_has_userstatus();
  ::GameServer::tagUserStatus* temp = userstatus_;
  userstatus_ = NULL;
  return temp;
}
inline void GSUserStatus::set_allocated_userstatus(::GameServer::tagUserStatus* userstatus) {
  delete userstatus_;
  userstatus_ = userstatus;
  if (userstatus) {
    set_has_userstatus();
  } else {
    clear_has_userstatus();
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSUserStatus.userStatus)
}

// -------------------------------------------------------------------

// GSUserScore

// required int32 userID = 1;
inline bool GSUserScore::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserScore::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserScore::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserScore::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserScore::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserScore.userID)
  return userid_;
}
inline void GSUserScore::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserScore.userID)
}

// required .GameServer.tagUserScore userScore = 2;
inline bool GSUserScore::has_userscore() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSUserScore::set_has_userscore() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSUserScore::clear_has_userscore() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSUserScore::clear_userscore() {
  if (userscore_ != NULL) userscore_->::GameServer::tagUserScore::Clear();
  clear_has_userscore();
}
inline const ::GameServer::tagUserScore& GSUserScore::userscore() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserScore.userScore)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return userscore_ != NULL ? *userscore_ : *default_instance().userscore_;
#else
  return userscore_ != NULL ? *userscore_ : *default_instance_->userscore_;
#endif
}
inline ::GameServer::tagUserScore* GSUserScore::mutable_userscore() {
  set_has_userscore();
  if (userscore_ == NULL) userscore_ = new ::GameServer::tagUserScore;
  // @@protoc_insertion_point(field_mutable:GameServer.GSUserScore.userScore)
  return userscore_;
}
inline ::GameServer::tagUserScore* GSUserScore::release_userscore() {
  clear_has_userscore();
  ::GameServer::tagUserScore* temp = userscore_;
  userscore_ = NULL;
  return temp;
}
inline void GSUserScore::set_allocated_userscore(::GameServer::tagUserScore* userscore) {
  delete userscore_;
  userscore_ = userscore;
  if (userscore) {
    set_has_userscore();
  } else {
    clear_has_userscore();
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSUserScore.userScore)
}

// -------------------------------------------------------------------

// GSGameOption

// required int32 userID = 1;
inline bool GSGameOption::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSGameOption::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSGameOption::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSGameOption::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSGameOption::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSGameOption.userID)
  return userid_;
}
inline void GSGameOption::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSGameOption.userID)
}

// optional bool allowLookon = 2;
inline bool GSGameOption::has_allowlookon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSGameOption::set_has_allowlookon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSGameOption::clear_has_allowlookon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSGameOption::clear_allowlookon() {
  allowlookon_ = false;
  clear_has_allowlookon();
}
inline bool GSGameOption::allowlookon() const {
  // @@protoc_insertion_point(field_get:GameServer.GSGameOption.allowLookon)
  return allowlookon_;
}
inline void GSGameOption::set_allowlookon(bool value) {
  set_has_allowlookon();
  allowlookon_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSGameOption.allowLookon)
}

// -------------------------------------------------------------------

// GSUserReady

// required int32 userID = 1;
inline bool GSUserReady::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserReady::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserReady::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserReady::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserReady::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserReady.userID)
  return userid_;
}
inline void GSUserReady::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserReady.userID)
}

// -------------------------------------------------------------------

// Proto_GameStatus

// required int32 cbGameStatus = 1;
inline bool Proto_GameStatus::has_cbgamestatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proto_GameStatus::set_has_cbgamestatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proto_GameStatus::clear_has_cbgamestatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proto_GameStatus::clear_cbgamestatus() {
  cbgamestatus_ = 0;
  clear_has_cbgamestatus();
}
inline ::google::protobuf::int32 Proto_GameStatus::cbgamestatus() const {
  // @@protoc_insertion_point(field_get:GameServer.Proto_GameStatus.cbGameStatus)
  return cbgamestatus_;
}
inline void Proto_GameStatus::set_cbgamestatus(::google::protobuf::int32 value) {
  set_has_cbgamestatus();
  cbgamestatus_ = value;
  // @@protoc_insertion_point(field_set:GameServer.Proto_GameStatus.cbGameStatus)
}

// -------------------------------------------------------------------

// SQL_S_Scroll_Message

// required int32 bMessageType = 1;
inline bool SQL_S_Scroll_Message::has_bmessagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SQL_S_Scroll_Message::set_has_bmessagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SQL_S_Scroll_Message::clear_has_bmessagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SQL_S_Scroll_Message::clear_bmessagetype() {
  bmessagetype_ = 0;
  clear_has_bmessagetype();
}
inline ::google::protobuf::int32 SQL_S_Scroll_Message::bmessagetype() const {
  // @@protoc_insertion_point(field_get:GameServer.SQL_S_Scroll_Message.bMessageType)
  return bmessagetype_;
}
inline void SQL_S_Scroll_Message::set_bmessagetype(::google::protobuf::int32 value) {
  set_has_bmessagetype();
  bmessagetype_ = value;
  // @@protoc_insertion_point(field_set:GameServer.SQL_S_Scroll_Message.bMessageType)
}

// repeated string sScrollMsg = 2;
inline int SQL_S_Scroll_Message::sscrollmsg_size() const {
  return sscrollmsg_.size();
}
inline void SQL_S_Scroll_Message::clear_sscrollmsg() {
  sscrollmsg_.Clear();
}
inline const ::std::string& SQL_S_Scroll_Message::sscrollmsg(int index) const {
  // @@protoc_insertion_point(field_get:GameServer.SQL_S_Scroll_Message.sScrollMsg)
  return sscrollmsg_.Get(index);
}
inline ::std::string* SQL_S_Scroll_Message::mutable_sscrollmsg(int index) {
  // @@protoc_insertion_point(field_mutable:GameServer.SQL_S_Scroll_Message.sScrollMsg)
  return sscrollmsg_.Mutable(index);
}
inline void SQL_S_Scroll_Message::set_sscrollmsg(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GameServer.SQL_S_Scroll_Message.sScrollMsg)
  sscrollmsg_.Mutable(index)->assign(value);
}
inline void SQL_S_Scroll_Message::set_sscrollmsg(int index, const char* value) {
  sscrollmsg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.SQL_S_Scroll_Message.sScrollMsg)
}
inline void SQL_S_Scroll_Message::set_sscrollmsg(int index, const char* value, size_t size) {
  sscrollmsg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.SQL_S_Scroll_Message.sScrollMsg)
}
inline ::std::string* SQL_S_Scroll_Message::add_sscrollmsg() {
  return sscrollmsg_.Add();
}
inline void SQL_S_Scroll_Message::add_sscrollmsg(const ::std::string& value) {
  sscrollmsg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GameServer.SQL_S_Scroll_Message.sScrollMsg)
}
inline void SQL_S_Scroll_Message::add_sscrollmsg(const char* value) {
  sscrollmsg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GameServer.SQL_S_Scroll_Message.sScrollMsg)
}
inline void SQL_S_Scroll_Message::add_sscrollmsg(const char* value, size_t size) {
  sscrollmsg_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GameServer.SQL_S_Scroll_Message.sScrollMsg)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SQL_S_Scroll_Message::sscrollmsg() const {
  // @@protoc_insertion_point(field_list:GameServer.SQL_S_Scroll_Message.sScrollMsg)
  return sscrollmsg_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SQL_S_Scroll_Message::mutable_sscrollmsg() {
  // @@protoc_insertion_point(field_mutable_list:GameServer.SQL_S_Scroll_Message.sScrollMsg)
  return &sscrollmsg_;
}

// -------------------------------------------------------------------

// GSSystemMessage

// required int32 messageType = 1;
inline bool GSSystemMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSSystemMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSSystemMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSSystemMessage::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::google::protobuf::int32 GSSystemMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:GameServer.GSSystemMessage.messageType)
  return messagetype_;
}
inline void GSSystemMessage::set_messagetype(::google::protobuf::int32 value) {
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSSystemMessage.messageType)
}

// required string messageString = 2;
inline bool GSSystemMessage::has_messagestring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GSSystemMessage::set_has_messagestring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GSSystemMessage::clear_has_messagestring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GSSystemMessage::clear_messagestring() {
  if (messagestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagestring_->clear();
  }
  clear_has_messagestring();
}
inline const ::std::string& GSSystemMessage::messagestring() const {
  // @@protoc_insertion_point(field_get:GameServer.GSSystemMessage.messageString)
  return *messagestring_;
}
inline void GSSystemMessage::set_messagestring(const ::std::string& value) {
  set_has_messagestring();
  if (messagestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagestring_ = new ::std::string;
  }
  messagestring_->assign(value);
  // @@protoc_insertion_point(field_set:GameServer.GSSystemMessage.messageString)
}
inline void GSSystemMessage::set_messagestring(const char* value) {
  set_has_messagestring();
  if (messagestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagestring_ = new ::std::string;
  }
  messagestring_->assign(value);
  // @@protoc_insertion_point(field_set_char:GameServer.GSSystemMessage.messageString)
}
inline void GSSystemMessage::set_messagestring(const char* value, size_t size) {
  set_has_messagestring();
  if (messagestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagestring_ = new ::std::string;
  }
  messagestring_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameServer.GSSystemMessage.messageString)
}
inline ::std::string* GSSystemMessage::mutable_messagestring() {
  set_has_messagestring();
  if (messagestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagestring_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GameServer.GSSystemMessage.messageString)
  return messagestring_;
}
inline ::std::string* GSSystemMessage::release_messagestring() {
  clear_has_messagestring();
  if (messagestring_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = messagestring_;
    messagestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GSSystemMessage::set_allocated_messagestring(::std::string* messagestring) {
  if (messagestring_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messagestring_;
  }
  if (messagestring) {
    set_has_messagestring();
    messagestring_ = messagestring;
  } else {
    clear_has_messagestring();
    messagestring_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GameServer.GSSystemMessage.messageString)
}

// -------------------------------------------------------------------

// GSUserHeart

// optional int32 userID = 1;
inline bool GSUserHeart::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GSUserHeart::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GSUserHeart::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GSUserHeart::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 GSUserHeart::userid() const {
  // @@protoc_insertion_point(field_get:GameServer.GSUserHeart.userID)
  return userid_;
}
inline void GSUserHeart::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:GameServer.GSUserHeart.userID)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace GameServer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameServer_2eproto__INCLUDED
